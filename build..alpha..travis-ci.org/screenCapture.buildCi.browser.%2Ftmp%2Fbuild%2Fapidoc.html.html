<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/tjworks/angoose">angoose (v0.3.21)</a>
</h1>
<h4>Angoose is a Remote Method Invocation module that comes with built-in mongoose/angular support. Now you can call server side module in browser just like you're in the server side!</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose">module angoose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose">
            function <span class="apidocSignatureSpan"></span>angoose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle">
            function <span class="apidocSignatureSpan">angoose.</span>Bundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Context">
            function <span class="apidocSignatureSpan">angoose.</span>Context
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception">
            function <span class="apidocSignatureSpan">angoose.</span>Exception
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model">
            function <span class="apidocSignatureSpan">angoose.</span>Model
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline">
            function <span class="apidocSignatureSpan">angoose.</span>Pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Principal">
            function <span class="apidocSignatureSpan">angoose.</span>Principal
            <span class="apidocSignatureSpan">(userId, roles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable">
            function <span class="apidocSignatureSpan">angoose.</span>Remotable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService">
            function <span class="apidocSignatureSpan">angoose.</span>SampleService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUser
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service">
            function <span class="apidocSignatureSpan">angoose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo">
            function <span class="apidocSignatureSpan">angoose.</span>Todo
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.client">
            function <span class="apidocSignatureSpan">angoose.</span>client
            <span class="apidocSignatureSpan">(forceGenerate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.config">
            function <span class="apidocSignatureSpan">angoose.</span>config
            <span class="apidocSignatureSpan">(path, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.defer">
            function <span class="apidocSignatureSpan">angoose.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.execute">
            function <span class="apidocSignatureSpan">angoose.</span>execute
            <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.extension">
            function <span class="apidocSignatureSpan">angoose.</span>extension
            <span class="apidocSignatureSpan">(name, module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.generateClient">
            function <span class="apidocSignatureSpan">angoose.</span>generateClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getClass">
            function <span class="apidocSignatureSpan">angoose.</span>getClass
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getContext">
            function <span class="apidocSignatureSpan">angoose.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getLogger">
            function <span class="apidocSignatureSpan">angoose.</span>getLogger
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getMongoose">
            function <span class="apidocSignatureSpan">angoose.</span>getMongoose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.hasModule">
            function <span class="apidocSignatureSpan">angoose.</span>hasModule
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.inContext">
            function <span class="apidocSignatureSpan">angoose.</span>inContext
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.init">
            function <span class="apidocSignatureSpan">angoose.</span>init
            <span class="apidocSignatureSpan">(app, conf, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.module">
            function <span class="apidocSignatureSpan">angoose.</span>module
            <span class="apidocSignatureSpan">(name, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.moduleNames">
            function <span class="apidocSignatureSpan">angoose.</span>moduleNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.rmiAccept">
            function <span class="apidocSignatureSpan">angoose.</span>rmiAccept
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.service">
            function <span class="apidocSignatureSpan">angoose.</span>service
            <span class="apidocSignatureSpan">(nameOpts, proto)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.setContext">
            function <span class="apidocSignatureSpan">angoose.</span>setContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.testContext">
            function <span class="apidocSignatureSpan">angoose.</span>testContext
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toString">
            function <span class="apidocSignatureSpan">angoose.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Bundle.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Pipeline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Remotable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>SampleUser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Service.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>angoose_authorization</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>angoose_mongoose</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>mongoose</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Bundle">module angoose.Bundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.Bundle">
            function <span class="apidocSignatureSpan">angoose.</span>Bundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.initHooks">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>initHooks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.post">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>post
            <span class="apidocSignatureSpan">(method, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.pre">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>pre
            <span class="apidocSignatureSpan">(method, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.typeOf">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>typeOf
            <span class="apidocSignatureSpan">(funcBody)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Bundle.prototype">module angoose.Bundle.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.configClient">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>configClient
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.createBundle">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>createBundle
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.exportModule">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModule
            <span class="apidocSignatureSpan">(client, moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.exportModules">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModules
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.generateClient">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>generateClient
            <span class="apidocSignatureSpan">(clientData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Exception">module angoose.Exception</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception.Exception">
            function <span class="apidocSignatureSpan">angoose.</span>Exception
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception.super_">
            function <span class="apidocSignatureSpan">angoose.Exception.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Model">module angoose.Model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.Model">
            function <span class="apidocSignatureSpan">angoose.</span>Model
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.constructor">
            function <span class="apidocSignatureSpan">angoose.Model.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.extend">
            function <span class="apidocSignatureSpan">angoose.Model.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.getContext">
            function <span class="apidocSignatureSpan">angoose.Model.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.getSchema">
            function <span class="apidocSignatureSpan">angoose.Model.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.mixin">
            function <span class="apidocSignatureSpan">angoose.Model.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Model.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Pipeline">module angoose.Pipeline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.Pipeline">
            function <span class="apidocSignatureSpan">angoose.</span>Pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline._lazySetupHooks">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>_lazySetupHooks
            <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.accept">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>accept
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.execute">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>execute
            <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.hook">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>hook
            <span class="apidocSignatureSpan">(name, fn, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.post">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>post
            <span class="apidocSignatureSpan">(name, isAsync, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.pre">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>pre
            <span class="apidocSignatureSpan">(name, isAsync, fn, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.removePost">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePost
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.removePre">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePre
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.</span>hookables</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Pipeline.prototype">module angoose.Pipeline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.authorize">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>authorize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.formatError">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>formatError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.invoke">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>invoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.pack">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>pack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.redact">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>redact
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.resolveArguments">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveArguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.resolveTarget">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveTarget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>_posts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>_pres</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Remotable">module angoose.Remotable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.Remotable">
            function <span class="apidocSignatureSpan">angoose.</span>Remotable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.constructor">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.extend">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.getContext">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.isRemotableReserved">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>isRemotableReserved
            <span class="apidocSignatureSpan">(methodName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.mixin">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Remotable.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Remotable.prototype">module angoose.Remotable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.prototype.getContext">
            function <span class="apidocSignatureSpan">angoose.Remotable.prototype.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleService">module angoose.SampleService</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.SampleService">
            function <span class="apidocSignatureSpan">angoose.</span>SampleService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.config">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.getContext">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.getSchema">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.listFavoriteDestinations">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>listFavoriteDestinations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testErrorBack">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testErrorBack
            <span class="apidocSignatureSpan">($callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testExecutionContext">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testExecutionContext
            <span class="apidocSignatureSpan">($callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testPromiseReturn">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testPromiseReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleService.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUser">module angoose.SampleUser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.SampleUser">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUser
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.checkExists">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>checkExists
            <span class="apidocSignatureSpan">(email)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.getSample">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>getSample
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.model">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.SampleUser.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUser.prototype">module angoose.SampleUser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.prototype.getFullname">
            function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>getFullname
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.prototype.setPassword">
            function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>setPassword
            <span class="apidocSignatureSpan">(newPassword, $context, $callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>schema</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUserGroup">module angoose.SampleUserGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup.SampleUserGroup">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup.model">
            function <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Service">module angoose.Service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.Service">
            function <span class="apidocSignatureSpan">angoose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.constructor">
            function <span class="apidocSignatureSpan">angoose.Service.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.extend">
            function <span class="apidocSignatureSpan">angoose.Service.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.getContext">
            function <span class="apidocSignatureSpan">angoose.Service.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.getSchema">
            function <span class="apidocSignatureSpan">angoose.Service.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.mixin">
            function <span class="apidocSignatureSpan">angoose.Service.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Service.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Service.prototype">module angoose.Service.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.prototype.toJSON">
            function <span class="apidocSignatureSpan">angoose.Service.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Service.prototype.</span>__classvars__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Todo">module angoose.Todo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo.Todo">
            function <span class="apidocSignatureSpan">angoose.</span>Todo
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo.model">
            function <span class="apidocSignatureSpan">angoose.Todo.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.Todo.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.angoose_authorization">module angoose.angoose_authorization</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.beforeCreateBundle">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>beforeCreateBundle
            <span class="apidocSignatureSpan">( client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.config">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.getContext">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.getSchema">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.postAuthorize">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postAuthorize
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.postInvoke">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postInvoke
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.preAuthorize">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preAuthorize
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.preRedact">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preRedact
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>_angoosemeta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.angoose_mongoose">module angoose.angoose_mongoose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.afterFormatError">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>afterFormatError
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.config">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.getContext">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.getSchema">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postExportModule">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postExportModule
            <span class="apidocSignatureSpan">( client, moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postInvoke">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postInvoke
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postPack">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postPack
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postResolveTarget">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postResolveTarget
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>_angoosemeta</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose" id="apidoc.module.angoose">module angoose</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose" id="apidoc.element.angoose.angoose">
        function <span class="apidocSignatureSpan"></span>angoose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angoose(){
    return lookupOrRegister.apply(null, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle" id="apidoc.element.angoose.Bundle">
        function <span class="apidocSignatureSpan">angoose.</span>Bundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bundle(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&gt;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.<span class="apidocCodeKeywordSpan">Bundle</span>().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug("Added mongoose model", MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Context" id="apidoc.element.angoose.Context">
        function <span class="apidocSignatureSpan">angoose.</span>Context
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Context(properties){
    this.seqnum =  properties.seqnum || (++seqnum);
    var props = properties;

    this.request = props.request;
    this.response = props.response;


    // ** getRequest() **
    //
    // Returns the express request object
    this.getRequest = function(){
        return props.request;
    }

    // ** getResponse **
    //
    // Returns the express response object
    this.getResponse = function(){
        return props.response;
    }

    // ** getInvocation **
    //
    // Returns the invocation object associated with current context
    this.getInvocation = function(){
        return this.invocation;
    }

    this.setUser = function(user){
        this.user = user;
    }
    this.getUser = function(){
        return this.user;
    }

    this.setPrincipal = function(principal){
        props.principal = principal;
    }
    // not used yet
    this.getPrincipal = function(){
        if(props.principal) return props.principal;
        return new Principal();
    }

    this.toString = function(){
        return "[Context@"+ this.seqnum+"]"
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Exception" id="apidoc.element.angoose.Exception">
        function <span class="apidocSignatureSpan">angoose.</span>Exception
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exception(err, name){
    if(err instanceof Error){
        this.message = err.message;
        this.name = name || err.name;
        require('traverse')(err).forEach(function(){
            if(this.circular) this.remove();
        })
        this.cause = err;
        //this.cause = err;
        //delete this.cause.domain;
    }
    else{
        this.message = err;
        this.name =  name || '';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model" id="apidoc.element.angoose.Model">
        function <span class="apidocSignatureSpan">angoose.</span>Model
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline" id="apidoc.element.angoose.Pipeline">
        function <span class="apidocSignatureSpan">angoose.</span>Pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Principal" id="apidoc.element.angoose.Principal">
        function <span class="apidocSignatureSpan">angoose.</span>Principal
        <span class="apidocSignatureSpan">(userId, roles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Principal = function (userId, roles){
    var user = {
        userId: userId,
        //username: username,
        roles: Array.isArray(roles)?roles: (roles?[roles]:undefined)
    }
    // ** getUsername() **
    //
    // get current logged in user's name/login
    //this.getUsername = function(){ return user.username};

    // ** getRoles **
    //
    // get current logged in user's roles, always returns an array
    this.getRoles = function(){ return user.roles || [] };

    // ** getUserId **
    //
    // get current logged in user's ID
    this.getUserId = function(){ return user.userId};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function preAuth(next){
    logger().trace("in preAuth", session().$authenticatedUser);
    var authUser = session().$authenticatedUser;
    if(authUser){
        logger().trace("Found user in session",    authUser);
        //angoose.getContext().setUser( session().$authenticatedUser );
        angoose.getContext().setPrincipal( new angoose.<span class="apidocCodeKeywordSpan">Principal</span>( authUser.userId, authUser
.roles) );
    }
    else{
        angoose.getContext().setPrincipal( new angoose.Principal( 'guest', 'guest' ));
    }
    next();
};
function logger(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable" id="apidoc.element.angoose.Remotable">
        function <span class="apidocSignatureSpan">angoose.</span>Remotable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Remotable = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService" id="apidoc.element.angoose.SampleService">
        function <span class="apidocSignatureSpan">angoose.</span>SampleService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SampleService = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser" id="apidoc.element.angoose.SampleUser">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUser
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup" id="apidoc.element.angoose.SampleUserGroup">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service" id="apidoc.element.angoose.Service">
        function <span class="apidocSignatureSpan">angoose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Service = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Todo" id="apidoc.element.angoose.Todo">
        function <span class="apidocSignatureSpan">angoose.</span>Todo
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.client" id="apidoc.element.angoose.client">
        function <span class="apidocSignatureSpan">angoose.</span>client
        <span class="apidocSignatureSpan">(forceGenerate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClient(forceGenerate){
    if(!angoose.initialized ||  forceGenerate)
        generateClient();
    return require(options['client-file']);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.config" id="apidoc.element.angoose.config">
        function <span class="apidocSignatureSpan">angoose.</span>config
        <span class="apidocSignatureSpan">(path, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, val){
    if(!path) return options;<span class="apidocCodeCommentSpan"> /**@todo: probably a deep copy */
</span>    if(!angoose.initialized &amp;&amp; typeof(path) == 'string') throw "Cannot call config(" + path+") before angoose is intialized";
    //if(angoose.initialized &amp;&amp; typeof(conf) == 'object') throw "Cannot config Angoose after startup";

    if(typeof (path) === 'string'){
         if(val === undefined)
            return toolbox.getter(options, path);
         toolbox.setter(options, path, val);
    }

    if(typeof(path) === 'object'){
        // deep merge
        options = toolbox.merge(options, path);

    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require("./test/server").startServer();
    });

    grunt.registerTask('autotest', 'watch and test', function(argPattern) {

        var watched= ["lib/**/*.js", "test/**/*.js", "models/**/*.js", "extensions/**/*.js"
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>('watch.autotest.files', watched);
        grunt.config('watch.autotest.tasks',  (argPattern? 'test:'+ argPattern: 'test'));
        grunt.task.run(argPattern? 'test:'+ argPattern: 'test');
        grunt.task.run('watch:autotest');

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.defer" id="apidoc.element.angoose.defer">
        function <span class="apidocSignatureSpan">angoose.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer(){
    return Q.defer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                var req = ctx.getRequest();
                $callback(false, req.params['method']);
        }))
}
// static method
SampleService.testPromiseReturn=function(){
    console.log("testPromiseReturn!");
    var out = Q.<span class="apidocCodeKeywordSpan">defer</span>();
    out.resolve("PromiseOK");
    process.nextTick(function(){
        out.resolve("PromiseOK");
    })
    return out.promise;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.execute" id="apidoc.element.angoose.execute">
        function <span class="apidocSignatureSpan">angoose.</span>execute
        <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (ctx, invocation, callback){
        ['allowed', 'target', 'arguments','result','redacted'].forEach(function(key){
            delete invocation[key];
        });

        var dmain = domain.create();
        dmain.context = ctx;
        //var excutionStorage = storageFactory.createNamespace("angoose");
<span class="apidocCodeCommentSpan">        /** here comes the main body of the processing */
</span>        dmain.run(function(){
                var pipeline = new Pipeline();
                var seqnum = invocation.seqnumber;
                var sent = false;
                logger.debug("------ BEGIN RMI #", seqnum, invocation.clazz, invocation.method );
                logger.trace("Invocation object: ",invocation);
                //invocation.method = req.params.method;  /** method must be part of the path for routes permission etc */
                ctx.seqnum = seqnum;
                ctx.invocation = invocation;

                function handleError(err, exName){
                    if(sent){
                        logger.debug("Response already sent")
                        return;
                    }
                    /**@todo: err may cause Circular issue when converting to JSON */
                    var ex = new Exception(err, exName);
                    invocation.exception = ex;

                    pipeline.formatError(invocation, function(er){
                        logger.debug("====== END RMI with Error  #", seqnum,  ex);
                        callback(invocation.packed);
                        sent  = true;
                    });
                }
                dmain.on('error',  function uncaught(ex){
                    logger.error("Uncaught error in invocation #"+seqnum, ex);
                    /**@todo: restart server if too many errors */
                    handleError(  "Unexpected Server Error", 'RuntimeError');
                });

                /** setting execution context */
                var sent = false;

                var modelName = invocation.clazz;
                var seqnum = invocation.seqnumber;
                //excutionStorage.set("context", ctx);
                pipeline.authorize(invocation,   function(err){
                    if(err) return handleError(err);
                    if(! invocation.allowed) return handleError("Access Denied", "AuthError");

                    pipeline.resolveTarget(invocation,   function(err){
                        if(err) return handleError(err);

                        if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");

                        pipeline.resolveArguments(invocation,function(err){
                            if(err) return handleError(err);

                            if(!invocation.arguments) return handleError("Arguments not resolved.");
                            pipeline.invoke(invocation, function(ex){

                                if(ex) return handleError(ex);
                                pipeline.redact(invocation, function(err){
                                    if(err) return handleError(err);
                                    pipeline.pack(invocation, function(err){
                                        if(err) return handleError(err);
                                        //res.send(200, packedData);
                                        callback(invocation.packed);
                                        sent = true;
                                        logger.debug("====== END RMI Succeeded #", seqnum);
                                        if(Array.isArray(invocation.packed &amp;&amp; invocation.packed.retval) &amp;&amp; invocation.packed.retval
.length&gt;0){
                                            logger.trace("Response is an array with length:",  invocation.packed.retval.length, "
First element:",invocation.packed.retval[0] ); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        });/** end context closure */
}

Pipeline.accept = function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.<span class="apidocCodeKeywordSpan">execute</span>(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.extension" id="apidoc.element.angoose.extension">
        function <span class="apidocSignatureSpan">angoose.</span>extension
        <span class="apidocSignatureSpan">(name, module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerExtension(name, module){
     if( typeof(name) =='object' )
        name.isExtension = true;
     else
        name = {name: name, isExtension:true}
     return registerClass(name,module);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
preAuthorize: preAuth,
postAuthorize: postAuth,
preRedact: redact,
postInvoke: postInvoke,
beforeCreateBundle: beforeCreateBundle
};

module.exports = angoose.<span class="apidocCodeKeywordSpan">extension</span>('AngooseAuthorization',  authExt);

function preAuth(next){
logger().trace("in preAuth", session().$authenticatedUser);
var authUser = session().$authenticatedUser;
if(authUser){
    logger().trace("Found user in session",    authUser);
    //angoose.getContext().setUser( session().$authenticatedUser );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.generateClient" id="apidoc.element.angoose.generateClient">
        function <span class="apidocSignatureSpan">angoose.</span>generateClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateClient(){
    logger.debug("Generating angoose client file: ");
    var bundle = new Bundle();
    var client = {};
    bundle.generateClient(client);
    var filename = angoose.config()['client-file'];
    writeToFile(filename, client.source)
    //compressFile(filename, client.source);
    logger.info("Generated  angoose client file: ", filename);
    return client.source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getClass" id="apidoc.element.angoose.getClass">
        function <span class="apidocSignatureSpan">angoose.</span>getClass
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClass(name){
    name = toolbox.camelcase(name);
    if(!beans[name]) throw "Class '"+ name+"' is not found. Check log to see if class is loaded successfully "
    return beans[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    logger.debug("Skipping default: resolveTarget");
    return resolveBack();
}

if(!invocation.static &amp;&amp; typeof(invocation.instance) != 'object')
    return resolveBack(  new Error("Missing invocation instance property" ));

var modelClass = angoose().<span class="apidocCodeKeywordSpan">getClass</span>( invocation.clazz );
if(invocation.static){
    invocation.target = modelClass;
    return resolveBack();
}

invocation.target = new modelClass(invocation.instance);
return resolveBack( );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getContext" id="apidoc.element.angoose.getContext">
        function <span class="apidocSignatureSpan">angoose.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContext(){

    if(!domain.active || !domain.active.context){
        if(this.mockContext) return this.mockContext

        logger.error("getContext called but no active domain", domain.active);
        logger.error("Caller is ",   arguments.callee &amp;&amp; arguments.callee.caller &amp;&amp; arguments.callee.caller.name, arguments.callee
 &amp;&amp; arguments.callee.caller );
        throw "Context not available. This may happen if the code was not originated by Angoose";
    }

    return domain.active.context;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getLogger" id="apidoc.element.angoose.getLogger">
        function <span class="apidocSignatureSpan">angoose.</span>getLogger
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name){
    name = name || 'angoose';
    return require("log4js").getLogger(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 else{
     angoose.getContext().setPrincipal( new angoose.Principal( 'guest', 'guest' ));
 }
 next();
};
function logger(){
 var extensionOptions = angoose.config()[EXTENSION] ;
 angoose.<span class="apidocCodeKeywordSpan">getLogger</span>('angoose-authorization').setLevel((extensionOptions &amp;
;&amp; extensionOptions.logging) || 'INFO');
 return angoose.getLogger('angoose-authorization')
}
function postAuth(next, invocation){
var extensionOptions = angoose.config()[EXTENSION]  ;

var ctx = angoose.getContext();
var user = ctx.getPrincipal();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getMongoose" id="apidoc.element.angoose.getMongoose">
        function <span class="apidocSignatureSpan">angoose.</span>getMongoose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMongoose(){
    angoose.mongoose = angoose.mongoose || options.mongoose;
    if(!angoose.mongoose){
        try{
            angoose.mongoose =  module.parent.require('mongoose');
            logger.debug("Required mongoose from parent")
        }
        catch(err){
            logger.debug("No mongoose in parent module");
            angoose.mongoose = require("mongoose");
        }

    }
    return angoose.mongoose;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               var path = category +"." +  toolbox.camelcase(group);
               var field = {};
               field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
               authSchema.add(field);
           }
        };
    });
    var mongooseModel =  angoose.<span class="apidocCodeKeywordSpan">getMongoose</span>().modelNames().indexOf(MODEL_NAME)&gt;=
0? angoose.getMongoose().model(MODEL_NAME):angoose.getMongoose().model(MODEL_NAME, authSchema) ;
    var permModule = angoose.module(MODEL_NAME, mongooseModel);
    new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods(MODEL_NAME, permModule);
    logger().debug("Added mongoose model", MODEL_NAME);

    setupInitialRoles();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.hasModule" id="apidoc.element.angoose.hasModule">
        function <span class="apidocSignatureSpan">angoose.</span>hasModule
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasModule(name){
    return beans[name] ? true : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.inContext" id="apidoc.element.angoose.inContext">
        function <span class="apidocSignatureSpan">angoose.</span>inContext
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inContext(fn){
<span class="apidocCodeCommentSpan">    /** there is a known issue with CLS that it does not work with MongoDB,
     * needs to bind the callback with the CLS context
     * https://github.com/othiym23/node-continuation-local-storage/issues/6
     * */
</span>    if(domain.active) return domain.active.bind(fn);
    return fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.init" id="apidoc.element.angoose.init">
        function <span class="apidocSignatureSpan">angoose.</span>init
        <span class="apidocSignatureSpan">(app, conf, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init(app, conf, force) {
    if(this.initialized &amp;&amp; !force) return;

    //beans = {};
<span class="apidocCodeCommentSpan">    /** configurations*/
</span>    initialConfig(conf);

    logger.info("Angoose Initialization Start");
    logger.trace("Init options:", conf);

    /** connect to Mongo if necessary */
    connectMongo(options);

    /** register initial hooks */
    //registerHooks();

    /** pre-load models/services from directories */
    harvestModules(options);

    /** plugin extensions */
    hookupExtensions();

    /** build client side schemas */
    generateClient();

    /** configure the routes for handling RMI and client loading*/
    /**@todo: middleware*/
    configureRoutes(app, options);

    logger.info("Angoose Initialization Complete");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	app.configure(function() {
		app.use(express.favicon());
		app.use(express.bodyParser());
		...
	});

	/** Angoose bootstraping */
    require("angoose").<span class="apidocCodeKeywordSpan">init</span>(app, {
       'module-dirs':'/models',
       'mongo-opts': 'localhost:27017/test',
    });

Here we assume your Mongoose model files are defined under `models` sub directory relative to the current dir where you start your
 app.

Restart node.js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.module" id="apidoc.element.angoose.module">
        function <span class="apidocSignatureSpan">angoose.</span>module
        <span class="apidocSignatureSpan">(name, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupOrRegister(name, target){
    if(arguments.length == 0) return null;
    if(arguments.length == 1) return getClass(name);
    if(arguments.length == 2) return registerClass(name, target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- The `/angoose/angoose-client.js` route will be handled by Angoose in the backend.
- This file contains dynamic content based on your backend models. If you don't see updates in your client after changing backend
, make sure no cache is in play.



#### 4. In your main angular app, add `angoose-client` to your app module dependencies. For example:

    var myapp = angular.<span class="apidocCodeKeywordSpan">module</span>('myapp', ['ngRoute',   'angoose
.client']);

#### 5. You are ready to go!

All the models defined in the `./models` folder will be auto-loaded and readily available for injection into your controller/service
/directives etc,
just delcare them in the function argument list(We're using `SampleUser` as example here):

	angular.module('myapp').controller('UserCtrl', function($scope, SampleUser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.moduleNames" id="apidoc.element.angoose.moduleNames">
        function <span class="apidocSignatureSpan">angoose.</span>moduleNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moduleNames(){
    return Object.keys(beans);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.rmiAccept" id="apidoc.element.angoose.rmiAccept">
        function <span class="apidocSignatureSpan">angoose.</span>rmiAccept
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.execute(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.service" id="apidoc.element.angoose.service">
        function <span class="apidocSignatureSpan">angoose.</span>service
        <span class="apidocSignatureSpan">(nameOpts, proto)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function service(nameOpts, proto){
    logger.debug("creating service ", nameOpts, typeof(proto));
    var opts = typeof(nameOpts) == 'string'? {name: nameOpts}: nameOpts;
    if(!opts.name) throw "Service name must be provided.";
    proto = proto || {};
    return angoose.Service.extend(proto, opts );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Unfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to
 make those modules with database/filesystem or other
external IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are
good usa case of Angoose modules.

Only modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:

- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.model()` call.
- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.<span class="apidocCodeKeywordSpan
">service</span>() is still supported and does same thing)

And for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.

There are a couple of exmaples under `angoose/models` directory for reference.

#### About Mongoose Models
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.setContext" id="apidoc.element.angoose.setContext">
        function <span class="apidocSignatureSpan">angoose.</span>setContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setContext(ctx){
    this.mockContext = ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.testContext" id="apidoc.element.angoose.testContext">
        function <span class="apidocSignatureSpan">angoose.</span>testContext
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testContext(name){

    if(!domain.active){
        domainLogger.debug("-------------------------------------- TEST-CONTEXT ", name, "NO ACTIVE DOMAIN");
        return;
    }
    if(!domain.active.context){
        domainLogger.debug("---------------------------------------TEST-CONTEXT ", name, "NO CONTEXT in active domain");
        return;
    }
    domainLogger.debug("-------------------------------------- TEST-CONTEXT ", name, "  OK ");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toString" id="apidoc.element.angoose.toString">
        function <span class="apidocSignatureSpan">angoose.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        schema.statics[m]= function remote(){};
});

schema.paths = traverse(model.schema.paths).map(function(item){
    if(!item) return;
    if(item.options &amp;&amp; typeof(item.options.type) === 'function' ){
        var fn = item.options.type;
        item.options.type = fn.name || fn.<span class="apidocCodeKeywordSpan">toString</span>();
    }
    else if(typeof(item) == 'function')
        this.update( 'not-supported' );
    if(item.requiredValidator) delete item.requiredValidator;
    if(item.enumValidator) delete item.enumValidator;
    if(item.validators) delete item.validators; /**@todo validators are not supported yet*/
});
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Bundle" id="apidoc.module.angoose.Bundle">module angoose.Bundle</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Bundle.Bundle" id="apidoc.element.angoose.Bundle.Bundle">
        function <span class="apidocSignatureSpan">angoose.</span>Bundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bundle(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&gt;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.<span class="apidocCodeKeywordSpan">Bundle</span>().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug("Added mongoose model", MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.initHooks" id="apidoc.element.angoose.Bundle.initHooks">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>initHooks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initHooks(){
    hooks.pre = {};
    hooks.post = {};
    ['generateClient','configClient','exportModules','exportModule','createBundle'].forEach(function(name){
        hooks.pre[name] = [];
        hooks.post[name] = [];
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.post" id="apidoc.element.angoose.Bundle.post">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>post
        <span class="apidocSignatureSpan">(method, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (method, func){
    return addHook('post', method, func)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.pre" id="apidoc.element.angoose.Bundle.pre">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>pre
        <span class="apidocSignatureSpan">(method, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pre = function (method, func){
    return addHook('pre', method, func)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getModelSchema(){
    var schema =  new angoose.getMongoose().Schema({
         role: {type:String, label:'Role', required:true, tags:['default-list'], unique:true },
         desc: {type:String, label:'Description',tags:['default-list']}
    }, {collection: COLLECTION_NAME});

    schema.<span class="apidocCodeKeywordSpan">pre</span>('save', function(next){
       cached =  null; // invalidate the cache
       next();
    });

    return schema;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.typeOf" id="apidoc.element.angoose.Bundle.typeOf">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>typeOf
        <span class="apidocSignatureSpan">(funcBody)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeOf = function (funcBody){
    funcBody = typeof(funcBody) == 'function' ? funcBody.toString() : funcBody;
    if(funcBody.indexOf("function")!=0) return "unknown";
    var matcher = FunctionNamePattern.exec(funcBody);
    return matcher? matcher[1]: 'remote'; //default is remote
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Bundle.prototype" id="apidoc.module.angoose.Bundle.prototype">module angoose.Bundle.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.configClient" id="apidoc.element.angoose.Bundle.prototype.configClient">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>configClient
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configClient = function (client){
    logger.debug("Setup client options");
    client.options = client.options || {};

    var angooseOpts = angoose().config();
    var clientOptionNames = ['url-prefix', 'logging'];

    _.extend(client.options, angooseOpts.client);
    client.options.urlPrefix = angooseOpts['url-prefix'];

    clientOptionNames.forEach(function(key){
        client.options[key] = angooseOpts[key];
    });
    //client.options.logging = angoose().config()['logging'] || 'INFO';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.createBundle" id="apidoc.element.angoose.Bundle.prototype.createBundle">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>createBundle
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBundle = function (client){
    logger.debug("Bundle client files");

    if(client.source) return; // already generated source
    var jsonSchemas = toolbox.stringifySchema( client.schemas );
    var template = path.resolve(__dirname , "client/angoose-client.js");
    var content = fs.readFileSync(template , 'ascii');
    content = content.replace("<span class="apidocCodeCommentSpan">/**SCHEMA_PLACEHOLDER*/",  jsonSchemas);
    content = content.replace("/**CONFIG_PLACEHOLDER*/", JSON.stringify( client.options ));

    /**  include client specific extensions*/
</span>    var clientModuleFile = path.resolve(__dirname , "client/angoose-angular.js");
    content += fs.readFileSync(clientModuleFile, 'ascii');

    clientModuleFile = path.resolve(__dirname , "client/angoose-jquery.js");
    content += fs.readFileSync(clientModuleFile, 'ascii');

    clientModuleFile = path.resolve(__dirname , "client/angoose-node.js");
    content += fs.readFileSync(clientModuleFile, 'ascii');

    client.source = content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.exportModule" id="apidoc.element.angoose.Bundle.prototype.exportModule">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModule
        <span class="apidocSignatureSpan">(client, moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportModule = function (client, moduleName){
    invokeHook('pre', 'exportModule', client, moduleName);

    logger.trace("in exportModule", moduleName);
    if(client.schemas[moduleName]) return; // already handled
    var mod = angoose().module(moduleName);
    var schema = toolbox.exportModuleMethods(moduleName, mod);
    if(!schema) logger.error("Module", moduleName, " has no schema, export failed", mod);
    else client.schemas[moduleName] = schema;

    invokeHook('post', 'exportModule', client, moduleName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&gt;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.Bundle().<span class="apidocCodeKeywordSpan">exportModule</span>(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug("Added mongoose model", MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.exportModules" id="apidoc.element.angoose.Bundle.prototype.exportModules">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModules
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportModules = function (client){
    invokeHook('pre', 'exportModules', client);

    logger.debug("Exporting all modules");
    client.schemas = client.schemas || {};
    var me = this;

    var names = angoose().moduleNames();
    var total = names &amp;&amp; names.length;
    if(!total) return;

    names.forEach(function(moduleName){
        var mod = angoose().getClass(moduleName);
        if(mod.config &amp;&amp; mod.config("visibility") === 'local') return;

        me.exportModule(client, moduleName);

    }) ;

    invokeHook('post', 'exportModules', client);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.generateClient" id="apidoc.element.angoose.Bundle.prototype.generateClient">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>generateClient
        <span class="apidocSignatureSpan">(clientData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateClient = function (clientData){
    invokeHook('pre', 'generateClient', clientData);
    // client side configurations

    invokeHook('pre', 'configClient', clientData);
    this.configClient(clientData);
    invokeHook('post', 'configClient', clientData);

    invokeHook('pre', 'exportModules', clientData);
    this.exportModules(clientData);
    invokeHook('post', 'exportModules', clientData);

    invokeHook('pre', 'createBundle', clientData);
    this.createBundle(clientData);
    invokeHook('post', 'createBundle', clientData);

    invokeHook('post', 'generateClient', clientData);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Exception" id="apidoc.module.angoose.Exception">module angoose.Exception</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Exception.Exception" id="apidoc.element.angoose.Exception.Exception">
        function <span class="apidocSignatureSpan">angoose.</span>Exception
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exception(err, name){
    if(err instanceof Error){
        this.message = err.message;
        this.name = name || err.name;
        require('traverse')(err).forEach(function(){
            if(this.circular) this.remove();
        })
        this.cause = err;
        //this.cause = err;
        //delete this.cause.domain;
    }
    else{
        this.message = err;
        this.name =  name || '';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Exception.super_" id="apidoc.element.angoose.Exception.super_">
        function <span class="apidocSignatureSpan">angoose.Exception.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Model" id="apidoc.module.angoose.Model">module angoose.Model</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Model.Model" id="apidoc.element.angoose.Model.Model">
        function <span class="apidocSignatureSpan">angoose.</span>Model
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.constructor" id="apidoc.element.angoose.Model.constructor">
        function <span class="apidocSignatureSpan">angoose.Model.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.extend" id="apidoc.element.angoose.Model.extend">
        function <span class="apidocSignatureSpan">angoose.Model.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace("Extending from ",   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == 'function'){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require("./angoose").registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.getContext" id="apidoc.element.angoose.Model.getContext">
        function <span class="apidocSignatureSpan">angoose.Model.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.getSchema" id="apidoc.element.angoose.Model.getSchema">
        function <span class="apidocSignatureSpan">angoose.Model.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSchema = function (){
    return this.schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.mixin" id="apidoc.element.angoose.Model.mixin">
        function <span class="apidocSignatureSpan">angoose.Model.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || 'Service';
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == 'Model')
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Pipeline" id="apidoc.module.angoose.Pipeline">module angoose.Pipeline</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Pipeline.Pipeline" id="apidoc.element.angoose.Pipeline.Pipeline">
        function <span class="apidocSignatureSpan">angoose.</span>Pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline._lazySetupHooks" id="apidoc.element.angoose.Pipeline._lazySetupHooks">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>_lazySetupHooks
        <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lazySetupHooks = function (proto, methodName, errorCb) {
  if ('undefined' === typeof proto[methodName].numAsyncPres) {
    this.hook(methodName, proto[methodName], errorCb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.accept" id="apidoc.element.angoose.Pipeline.accept">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>accept
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.execute(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.execute" id="apidoc.element.angoose.Pipeline.execute">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>execute
        <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (ctx, invocation, callback){
        ['allowed', 'target', 'arguments','result','redacted'].forEach(function(key){
            delete invocation[key];
        });

        var dmain = domain.create();
        dmain.context = ctx;
        //var excutionStorage = storageFactory.createNamespace("angoose");
<span class="apidocCodeCommentSpan">        /** here comes the main body of the processing */
</span>        dmain.run(function(){
                var pipeline = new Pipeline();
                var seqnum = invocation.seqnumber;
                var sent = false;
                logger.debug("------ BEGIN RMI #", seqnum, invocation.clazz, invocation.method );
                logger.trace("Invocation object: ",invocation);
                //invocation.method = req.params.method;  /** method must be part of the path for routes permission etc */
                ctx.seqnum = seqnum;
                ctx.invocation = invocation;

                function handleError(err, exName){
                    if(sent){
                        logger.debug("Response already sent")
                        return;
                    }
                    /**@todo: err may cause Circular issue when converting to JSON */
                    var ex = new Exception(err, exName);
                    invocation.exception = ex;

                    pipeline.formatError(invocation, function(er){
                        logger.debug("====== END RMI with Error  #", seqnum,  ex);
                        callback(invocation.packed);
                        sent  = true;
                    });
                }
                dmain.on('error',  function uncaught(ex){
                    logger.error("Uncaught error in invocation #"+seqnum, ex);
                    /**@todo: restart server if too many errors */
                    handleError(  "Unexpected Server Error", 'RuntimeError');
                });

                /** setting execution context */
                var sent = false;

                var modelName = invocation.clazz;
                var seqnum = invocation.seqnumber;
                //excutionStorage.set("context", ctx);
                pipeline.authorize(invocation,   function(err){
                    if(err) return handleError(err);
                    if(! invocation.allowed) return handleError("Access Denied", "AuthError");

                    pipeline.resolveTarget(invocation,   function(err){
                        if(err) return handleError(err);

                        if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");

                        pipeline.resolveArguments(invocation,function(err){
                            if(err) return handleError(err);

                            if(!invocation.arguments) return handleError("Arguments not resolved.");
                            pipeline.invoke(invocation, function(ex){

                                if(ex) return handleError(ex);
                                pipeline.redact(invocation, function(err){
                                    if(err) return handleError(err);
                                    pipeline.pack(invocation, function(err){
                                        if(err) return handleError(err);
                                        //res.send(200, packedData);
                                        callback(invocation.packed);
                                        sent = true;
                                        logger.debug("====== END RMI Succeeded #", seqnum);
                                        if(Array.isArray(invocation.packed &amp;&amp; invocation.packed.retval) &amp;&amp; invocation.packed.retval
.length&gt;0){
                                            logger.trace("Response is an array with length:",  invocation.packed.retval.length, "
First element:",invocation.packed.retval[0] ); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        });/** end context closure */
}

Pipeline.accept = function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.<span class="apidocCodeKeywordSpan">execute</span>(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.hook" id="apidoc.element.angoose.Pipeline.hook">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>hook
        <span class="apidocSignatureSpan">(name, fn, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hook = function (name, fn, errorCb) {
  if (arguments.length === 1 &amp;&amp; typeof name === 'object') {
    for (var k in name) { // `name` is a hash of hookName-&gt;hookFn
      this.hook(k, name[k]);
    }
    return;
  }

  var proto = this.prototype || this
    , pres = proto._pres = proto._pres || {}
    , posts = proto._posts = proto._posts || {};
  pres[name] = pres[name] || [];
  posts[name] = posts[name] || [];

  proto[name] = function () {
    var self = this
      , hookArgs // arguments eventually passed to the hook - are mutable
      , lastArg = arguments[arguments.length-1]
      , pres = this._pres[name]
      , posts = this._posts[name]
      , _total = pres.length
      , _current = -1
      , _asyncsLeft = proto[name].numAsyncPres
      , _next = function () {
          if (arguments[0] instanceof Error) {
            return handleError(arguments[0]);
          }
          var _args = Array.prototype.slice.call(arguments)
            , currPre
            , preArgs;
          if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
            hookArgs = _args;
          if (++_current &lt; _total) {
            currPre = pres[_current]
            if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
              throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
            if (currPre.length &lt; 1)
              throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
            preArgs = (currPre.isAsync
                        ? [once(_next), once(_asyncsDone)]
                        : [once(_next)]).concat(hookArgs);
            return currPre.apply(self, preArgs);
          } else if (!proto[name].numAsyncPres) {
            return _done.apply(self, hookArgs);
          }
        }
      , _done = function () {
          var args_ = Array.prototype.slice.call(arguments)
            , ret, total_, current_, next_, done_, postArgs;

          if (_current === _total) {

            next_ = function () {
              if (arguments[0] instanceof Error) {
                return handleError(arguments[0]);
              }
              var args_ = Array.prototype.slice.call(arguments, 1)
                , currPost
                , postArgs;
              if (args_.length) hookArgs = args_;
              if (++current_ &lt; total_) {
                currPost = posts[current_]
                if (currPost.length &lt; 1)
                  throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
                postArgs = [once(next_)].concat(hookArgs);
                return currPost.apply(self, postArgs);
              } else if (typeof lastArg === 'function'){
                // All post handlers are done, call original callback function
                return lastArg.apply(self, arguments);
              }
            };

            // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
            // a callback.  We trap that callback and wait to call it until all post handlers have finished.
            if(typeof lastArg === 'function'){
              args_[args_.length - 1] = once(next_);
            }

            total_ = posts.length;
            current_ = -1;
            ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

            if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
            return ret;
          }
        };
    if (_asyncsLeft) {
      function _asyncsDone (err) {
        if (err &amp;&amp; err instanceof Error) {
          return handleError(err);
        }
        --_asyncsLeft || _done.apply(self, hookArgs);
      }
    }
    function handleError (err) {
      if ('function' == typeof lastArg)
        return lastArg(err);
      if (errorCb) return errorCb.call(self, err);
      throw err;
    }
    return _next.apply(this, arguments);
  };

  proto[name].numAsyncPres = 0;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.post" id="apidoc.element.angoose.Pipeline.post">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>post
        <span class="apidocSignatureSpan">(name, isAsync, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (name, isAsync, fn) {
  if (arguments.length === 2) {
    fn = isAsync;
    isAsync = false;
  }
  var proto = this.prototype || this
    , posts = proto._posts = proto._posts || {};

  this._lazySetupHooks(proto, name);
  (posts[name] = posts[name] || []).push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.pre" id="apidoc.element.angoose.Pipeline.pre">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>pre
        <span class="apidocSignatureSpan">(name, isAsync, fn, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pre = function (name, isAsync, fn, errorCb) {
  if ('boolean' !== typeof arguments[1]) {
    errorCb = fn;
    fn = isAsync;
    isAsync = false;
  }
  var proto = this.prototype || this
    , pres = proto._pres = proto._pres || {};

  this._lazySetupHooks(proto, name, errorCb);

  if (fn.isAsync = isAsync) {
    proto[name].numAsyncPres++;
  }

  (pres[name] = pres[name] || []).push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getModelSchema(){
    var schema =  new angoose.getMongoose().Schema({
         role: {type:String, label:'Role', required:true, tags:['default-list'], unique:true },
         desc: {type:String, label:'Description',tags:['default-list']}
    }, {collection: COLLECTION_NAME});

    schema.<span class="apidocCodeKeywordSpan">pre</span>('save', function(next){
       cached =  null; // invalidate the cache
       next();
    });

    return schema;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.removePost" id="apidoc.element.angoose.Pipeline.removePost">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePost
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removePost(name, fnToRemove) {
    var proto = this.prototype || this
      , posts = proto._posts || (proto._posts || {});
    if (!posts[name]) return this;
    if (arguments.length === 1) {
      // Remove all pre callbacks for hook `name`
      posts[name].length = 0;
    } else {
      posts[name] = posts[name].filter( function (currFn) {
        return currFn !== fnToRemove;
      });
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.removePre" id="apidoc.element.angoose.Pipeline.removePre">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePre
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePre = function (name, fnToRemove) {
  var proto = this.prototype || this
    , pres = proto._pres || (proto._pres || {});
  if (!pres[name]) return this;
  if (arguments.length === 1) {
    // Remove all pre callbacks for hook `name`
    pres[name].length = 0;
  } else {
    pres[name] = pres[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Pipeline.prototype" id="apidoc.module.angoose.Pipeline.prototype">module angoose.Pipeline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.authorize" id="apidoc.element.angoose.Pipeline.prototype.authorize">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>authorize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorize = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/** setting execution context */
var sent = false;

var modelName = invocation.clazz;
var seqnum = invocation.seqnumber;
//excutionStorage.set("context", ctx);
pipeline.<span class="apidocCodeKeywordSpan">authorize</span>(invocation,   function(err){
    if(err) return handleError(err);
    if(! invocation.allowed) return handleError("Access Denied", "AuthError");

    pipeline.resolveTarget(invocation,   function(err){
        if(err) return handleError(err);

        if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.formatError" id="apidoc.element.angoose.Pipeline.prototype.formatError">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>formatError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatError = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        logger.debug("Response already sent")
        return;
    }
    /**@todo: err may cause Circular issue when converting to JSON */
    var ex = new Exception(err, exName);
    invocation.exception = ex;

    pipeline.<span class="apidocCodeKeywordSpan">formatError</span>(invocation, function(er){
        logger.debug("====== END RMI with Error  #", seqnum,  ex);
        callback(invocation.packed);
        sent  = true;
    });
}
dmain.on('error',  function uncaught(ex){
    logger.error("Uncaught error in invocation #"+seqnum, ex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.invoke" id="apidoc.element.angoose.Pipeline.prototype.invoke">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>invoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");

pipeline.resolveArguments(invocation,function(err){
    if(err) return handleError(err);

    if(!invocation.arguments) return handleError("Arguments not resolved.");
    pipeline.<span class="apidocCodeKeywordSpan">invoke</span>(invocation, function(ex){

        if(ex) return handleError(ex);
        pipeline.redact(invocation, function(err){
            if(err) return handleError(err);
            pipeline.pack(invocation, function(err){
                if(err) return handleError(err);
                //res.send(200, packedData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.pack" id="apidoc.element.angoose.Pipeline.prototype.pack">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>pack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pack = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!invocation.arguments) return handleError("Arguments not resolved.");
pipeline.invoke(invocation, function(ex){

    if(ex) return handleError(ex);
    pipeline.redact(invocation, function(err){
        if(err) return handleError(err);
        pipeline.<span class="apidocCodeKeywordSpan">pack</span>(invocation, function(err){
            if(err) return handleError(err);
            //res.send(200, packedData);
            callback(invocation.packed);
            sent = true;
            logger.debug("====== END RMI Succeeded #", seqnum);
            if(Array.isArray(invocation.packed &amp;&amp; invocation.packed.retval) &amp;&amp; invocation.packed.retval.length
&gt;0){
                logger.trace("Response is an array with length:",  invocation.packed.retval.length, "First element
:",invocation.packed.retval[0] );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.redact" id="apidoc.element.angoose.Pipeline.prototype.redact">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>redact
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redact = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        pipeline.resolveArguments(invocation,function(err){
if(err) return handleError(err);

if(!invocation.arguments) return handleError("Arguments not resolved.");
pipeline.invoke(invocation, function(ex){

    if(ex) return handleError(ex);
    pipeline.<span class="apidocCodeKeywordSpan">redact</span>(invocation, function(err){
        if(err) return handleError(err);
        pipeline.pack(invocation, function(err){
            if(err) return handleError(err);
            //res.send(200, packedData);
            callback(invocation.packed);
            sent = true;
            logger.debug("====== END RMI Succeeded #", seqnum);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.resolveArguments" id="apidoc.element.angoose.Pipeline.prototype.resolveArguments">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveArguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveArguments = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(! invocation.allowed) return handleError("Access Denied", "AuthError");

pipeline.resolveTarget(invocation,   function(err){
    if(err) return handleError(err);

    if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");

    pipeline.<span class="apidocCodeKeywordSpan">resolveArguments</span>(invocation,function(err){
        if(err) return handleError(err);

        if(!invocation.arguments) return handleError("Arguments not resolved.");
        pipeline.invoke(invocation, function(ex){

            if(ex) return handleError(ex);
            pipeline.redact(invocation, function(err){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.resolveTarget" id="apidoc.element.angoose.Pipeline.prototype.resolveTarget">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveTarget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveTarget = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &amp;&amp; !(arguments[0] == null &amp;&amp; typeof lastArg === 'function'))
          hookArgs = _args;
        if (++_current &lt; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &amp;&amp; currPre.length &lt; 2)
            throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
          if (currPre.length &lt; 1)
            throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &lt; total_) {
              currPost = posts[current_]
              if (currPost.length &lt; 1)
                throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === 'function'){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === 'function'){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &amp;&amp; typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &amp;&amp; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if ('function' == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelName = invocation.clazz;
var seqnum = invocation.seqnumber;
//excutionStorage.set("context", ctx);
pipeline.authorize(invocation,   function(err){
    if(err) return handleError(err);
    if(! invocation.allowed) return handleError("Access Denied", "AuthError");

    pipeline.<span class="apidocCodeKeywordSpan">resolveTarget</span>(invocation,   function(err){
        if(err) return handleError(err);

        if(!invocation.target) return handleError("Target not resolved.", "ModuleNotFoundError");

        pipeline.resolveArguments(invocation,function(err){
            if(err) return handleError(err);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Remotable" id="apidoc.module.angoose.Remotable">module angoose.Remotable</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Remotable.Remotable" id="apidoc.element.angoose.Remotable.Remotable">
        function <span class="apidocSignatureSpan">angoose.</span>Remotable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Remotable = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.constructor" id="apidoc.element.angoose.Remotable.constructor">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.extend" id="apidoc.element.angoose.Remotable.extend">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace("Extending from ",   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == 'function'){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require("./angoose").registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.getContext" id="apidoc.element.angoose.Remotable.getContext">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.isRemotableReserved" id="apidoc.element.angoose.Remotable.isRemotableReserved">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>isRemotableReserved
        <span class="apidocSignatureSpan">(methodName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRemotableReserved(methodName){
<span class="apidocCodeCommentSpan">    /** check if method is reserved by the Remotable interface */
</span>  return methodName.indexOf("_") == 0 || methodName.indexOf("$") == 0 || ['constructor',   'isRemotableReserved'].indexOf(methodName
)&gt;=0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.mixin" id="apidoc.element.angoose.Remotable.mixin">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || 'Service';
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == 'Model')
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Remotable.prototype" id="apidoc.module.angoose.Remotable.prototype">module angoose.Remotable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Remotable.prototype.getContext" id="apidoc.element.angoose.Remotable.prototype.getContext">
        function <span class="apidocSignatureSpan">angoose.Remotable.prototype.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleService" id="apidoc.module.angoose.SampleService">module angoose.SampleService</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleService.SampleService" id="apidoc.element.angoose.SampleService.SampleService">
        function <span class="apidocSignatureSpan">angoose.</span>SampleService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SampleService = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.config" id="apidoc.element.angoose.SampleService.config">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require("./test/server").startServer();
    });

    grunt.registerTask('autotest', 'watch and test', function(argPattern) {

        var watched= ["lib/**/*.js", "test/**/*.js", "models/**/*.js", "extensions/**/*.js"
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>('watch.autotest.files', watched);
        grunt.config('watch.autotest.tasks',  (argPattern? 'test:'+ argPattern: 'test'));
        grunt.task.run(argPattern? 'test:'+ argPattern: 'test');
        grunt.task.run('watch:autotest');

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.getContext" id="apidoc.element.angoose.SampleService.getContext">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.getSchema" id="apidoc.element.angoose.SampleService.getSchema">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != 'function') continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == 'function'){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.listFavoriteDestinations" id="apidoc.element.angoose.SampleService.listFavoriteDestinations">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>listFavoriteDestinations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listFavoriteDestinations = function (){
    return ["Paris", "Virgin Islands", "Antarctic"]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testErrorBack" id="apidoc.element.angoose.SampleService.testErrorBack">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testErrorBack
        <span class="apidocSignatureSpan">($callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testErrorBack = function ($callback){
    console.log("In testErrorCallback");
    $callback("Error in testError");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testExecutionContext" id="apidoc.element.angoose.SampleService.testExecutionContext">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testExecutionContext
        <span class="apidocSignatureSpan">($callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remote($callback){
        var self = this;
        var su = require("./SampleUser");
        su.findOne(angoose.bind(   function(err, res){
                var ctx = self.getContext();
                console.log("In testExecutionContext "+ ctx.seqnum)
                var req = ctx.getRequest();
                $callback(false, req.params['method']);
        }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testPromiseReturn" id="apidoc.element.angoose.SampleService.testPromiseReturn">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testPromiseReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testPromiseReturn = function (){
    console.log("testPromiseReturn!");
    var out = Q.defer();
    out.resolve("PromiseOK");
    process.nextTick(function(){
        out.resolve("PromiseOK");
    })
    return out.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUser" id="apidoc.module.angoose.SampleUser">module angoose.SampleUser</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUser.SampleUser" id="apidoc.element.angoose.SampleUser.SampleUser">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUser
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.checkExists" id="apidoc.element.angoose.SampleUser.checkExists">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>checkExists
        <span class="apidocSignatureSpan">(email)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExists = function (email){
    //_static_remote
    console.log("in checkExists",email);
    require("fs");  // do a server side operation to ensure this can only be done in the server side.
    if(email &amp;&amp; email.indexOf('new')&gt;=0) return false;
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.getSample" id="apidoc.element.angoose.SampleUser.getSample">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>getSample
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSample = function (){
    // this should refer to the model class
    console.log("get sample user");
    var instance = new this( sampleUserData);
    return instance;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.model" id="apidoc.element.angoose.SampleUser.model">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Wah, you say, so I can use every NPM module out there in my front end?

Unfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to
 make those modules with database/filesystem or other
external IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are
good usa case of Angoose modules.

Only modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:

- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.<span class="apidocCodeKeywordSpan
">model</span>()` call.
- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.service() is still supported
 and does same thing)

And for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.

There are a couple of exmaples under `angoose/models` directory for reference.

#### About Mongoose Models
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUser.prototype" id="apidoc.module.angoose.SampleUser.prototype">module angoose.SampleUser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUser.prototype.getFullname" id="apidoc.element.angoose.SampleUser.prototype.getFullname">
        function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>getFullname
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function portable(){
    //_instance_portable
    console.log("getFullname", this);
    return  (this.firstname ? this.firstname +" ": "") + (this.lastname || "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.prototype.setPassword" id="apidoc.element.angoose.SampleUser.prototype.setPassword">
        function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>setPassword
        <span class="apidocSignatureSpan">(newPassword, $context, $callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPassword = function (newPassword, $context, $callback){
    // instance method, reset user's password.
    if(!$callback ) throw "$callback not injected";
    if(!$context) throw "$context not injected";
    //var cryptor = require("crypto"); // require node module crypto
    //this.password = cryptor.encrypt("salt", newPassword);
    this.password  = newPassword +"salt123"; // fake code
    $callback(false, "Password changed");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUserGroup" id="apidoc.module.angoose.SampleUserGroup">module angoose.SampleUserGroup</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup.SampleUserGroup" id="apidoc.element.angoose.SampleUserGroup.SampleUserGroup">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup.model" id="apidoc.element.angoose.SampleUserGroup.model">
        function <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Wah, you say, so I can use every NPM module out there in my front end?

Unfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to
 make those modules with database/filesystem or other
external IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are
good usa case of Angoose modules.

Only modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:

- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.<span class="apidocCodeKeywordSpan
">model</span>()` call.
- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.service() is still supported
 and does same thing)

And for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.

There are a couple of exmaples under `angoose/models` directory for reference.

#### About Mongoose Models
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Service" id="apidoc.module.angoose.Service">module angoose.Service</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Service.Service" id="apidoc.element.angoose.Service.Service">
        function <span class="apidocSignatureSpan">angoose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Service = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.constructor" id="apidoc.element.angoose.Service.constructor">
        function <span class="apidocSignatureSpan">angoose.Service.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.extend" id="apidoc.element.angoose.Service.extend">
        function <span class="apidocSignatureSpan">angoose.Service.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace("Extending from ",   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == 'function'){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require("./angoose").registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.getContext" id="apidoc.element.angoose.Service.getContext">
        function <span class="apidocSignatureSpan">angoose.Service.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.getSchema" id="apidoc.element.angoose.Service.getSchema">
        function <span class="apidocSignatureSpan">angoose.Service.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSchema = function (){
    var thisClass = this;
    var schema = {statics: {} };

    schema.methods = _.extend({}, thisClass.prototype)

    for(var name in thisClass.prototype){
        if( filter(name) ) continue;
        if(!thisClass.prototype.hasOwnProperty(name)) continue;
        var val = thisClass.prototype[name];
        if(typeof(val)!='function') continue;
        schema.methods[name] = val;
    }

    for(var name in thisClass){
        if(!thisClass.hasOwnProperty(name)) continue;
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != 'function') continue;
        schema.statics[name] = val;
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.mixin" id="apidoc.element.angoose.Service.mixin">
        function <span class="apidocSignatureSpan">angoose.Service.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || 'Service';
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == 'Model')
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Service.prototype" id="apidoc.module.angoose.Service.prototype">module angoose.Service.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Service.prototype.toJSON" id="apidoc.element.angoose.Service.prototype.toJSON">
        function <span class="apidocSignatureSpan">angoose.Service.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
    return {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var valueType = getValueType(redacted);  /** model, models, object, string*/
    var retdata = { success:true,
                    exception:null,
                    retval:redacted,
                    datatype: valueType,
                    seqnumber:invocation.seqnumber
    };
    if( !invocation.static &amp;&amp; (! _.isEqual(target.<span class="apidocCodeKeywordSpan">toJSON</span>(), invocation.target
)))
    {
        /** return the instance data if it has changed */
        retdata.instance = target.toJSON();
    }
    invocation.packed = retdata;
    packBack();
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Todo" id="apidoc.module.angoose.Todo">module angoose.Todo</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Todo.Todo" id="apidoc.element.angoose.Todo.Todo">
        function <span class="apidocSignatureSpan">angoose.</span>Todo
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Todo.model" id="apidoc.element.angoose.Todo.model">
        function <span class="apidocSignatureSpan">angoose.Todo.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Wah, you say, so I can use every NPM module out there in my front end?

Unfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to
 make those modules with database/filesystem or other
external IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are
good usa case of Angoose modules.

Only modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:

- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.<span class="apidocCodeKeywordSpan
">model</span>()` call.
- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.service() is still supported
 and does same thing)

And for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.

There are a couple of exmaples under `angoose/models` directory for reference.

#### About Mongoose Models
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.angoose_authorization" id="apidoc.module.angoose.angoose_authorization">module angoose.angoose_authorization</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.beforeCreateBundle" id="apidoc.element.angoose.angoose_authorization.beforeCreateBundle">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>beforeCreateBundle
        <span class="apidocSignatureSpan">( client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function beforeCreateBundle( client){
    // generating PermissionModel schema used on UI
    logger().debug("in beforeCreateBundle");
    MODEL_NAME = angoose.config('angoose-authorization.model-name') || MODEL_NAME;
    COLLECTION_NAME = angoose.config('angoose-authorization.collection-name') || COLLECTION_NAME;

    var schemas = client.schemas;
    var authSchema = getModelSchema();
    // get list of all published methods
    Object.keys(schemas).forEach(function(moduleName){
        var schema = schemas[moduleName];
        if(!schema || moduleName == 'SampleUser') return;
        var methodNames =   Object.keys(schema.methods).concat(Object.keys(schema.statics));
        var mod = angoose.module(moduleName);
        if(mod.config &amp;&amp; mod.config("visibility") === false ) return;
        var category = getCategory(mod);
        for(var i=0;methodNames &amp;&amp; i&lt;methodNames.length;i++){
           var mName = methodNames[i];
           if(mName == 'config' || mName == 'getSchema') continue;
           var fn = schema.methods &amp;&amp; schema.methods[mName];
           fn = fn || (schema.statics &amp;&amp; schema.statics[mName]);
           if(toolbox.methodType(fn) != 'remote') continue;

           var group = getGroup(mod, mName);
           if(!group){
               var path = category +"." + mName;
               var field = {};
               field[path] = {type:Boolean, label: getLabel(mod,mName)};
               authSchema.add(field);
           }
           else if(!authSchema.path(group)){
               // add schema path for the permission group
               var path = category +"." +  toolbox.camelcase(group);
               var field = {};
               field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
               authSchema.add(field);
           }
        };
    });
    var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&gt;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
    var permModule = angoose.module(MODEL_NAME, mongooseModel);
    new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods(MODEL_NAME, permModule);
    logger().debug("Added mongoose model", MODEL_NAME);

    setupInitialRoles();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.config" id="apidoc.element.angoose.angoose_authorization.config">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require("./test/server").startServer();
    });

    grunt.registerTask('autotest', 'watch and test', function(argPattern) {

        var watched= ["lib/**/*.js", "test/**/*.js", "models/**/*.js", "extensions/**/*.js"
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>('watch.autotest.files', watched);
        grunt.config('watch.autotest.tasks',  (argPattern? 'test:'+ argPattern: 'test'));
        grunt.task.run(argPattern? 'test:'+ argPattern: 'test');
        grunt.task.run('watch:autotest');

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.getContext" id="apidoc.element.angoose.angoose_authorization.getContext">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.getSchema" id="apidoc.element.angoose.angoose_authorization.getSchema">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != 'function') continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == 'function'){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.postAuthorize" id="apidoc.element.angoose.angoose_authorization.postAuthorize">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postAuthorize
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postAuth(next, invocation){
   var extensionOptions = angoose.config()[EXTENSION]  ;

   var ctx = angoose.getContext();
   var user = ctx.getPrincipal();

   invocation.allowed = true;

<span class="apidocCodeCommentSpan">   /** admin user bypass */
</span>   var superuser =  extensionOptions &amp;&amp; extensionOptions.superuser
   if(user.getUserId() ===  superuser ) return next(); // always allow super user admin
   var superrole = ( extensionOptions &amp;&amp; extensionOptions.superrole ) || 'admin';
   if(user &amp;&amp; user.getRoles().indexOf(superrole) &gt;=0) return next();

   logger().trace("in auth.postAuth:", invocation.clazz, invocation.method);
   if(invocation.method == 'signin' || invocation.method=="signout") return next();

   var mod = angoose.module( invocation.clazz );
   var category = mod.config(EXTENSION +".category") || invocation.clazz;
   var group = toolbox.camelcase(getGroup(mod, invocation.method)) || invocation.method;

    var roles = user.getRoles() ? user.getRoles(): [];
    roles = Array.isArray(roles)? roles: [ roles ];
    if(roles.indexOf('guest') &lt;0) roles.push('guest');
    if(roles.indexOf('authenticated') &lt;0) roles.push('authenticated');

   var allowed = isAllowed( category +"."+ group, roles, function(allowed){
        logger().trace("isAllowed: ", category, group, allowed);
        invocation.allowed = allowed;
        next();
   });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.postInvoke" id="apidoc.element.angoose.angoose_authorization.postInvoke">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postInvoke
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postInvoke(next, invocation){
    // this is bizzare, if main method fails, this will be called with arguments meant for pre()
    //var invocation = angoose.getContext().getInvocation();
    if( ['signin', 'signout'].indexOf(invocation.method ) &lt;0 ) return next();;

    if(invocation.method == 'signout'){
        if(angoose.getContext().getRequest().session)
            angoose.getContext().getRequest().session.$authenticatedUser =   null;
        logger().debug("User logged out");
    }
    var data = invocation.result;
    logger().debug("Intercepting login methods", invocation.method, data);
    if(!data || !data.userId  )
        return next();;
    if(invocation.method == 'signin'){
        angoose.getContext().getRequest().session.$authenticatedUser =   {userId: data.userId, roles: data.roles } ;
        logger().debug("User authenticated", angoose.getContext().getRequest().session.$authenticatedUser );
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.preAuthorize" id="apidoc.element.angoose.angoose_authorization.preAuthorize">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preAuthorize
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preAuth(next){
    logger().trace("in preAuth", session().$authenticatedUser);
    var authUser = session().$authenticatedUser;
    if(authUser){
        logger().trace("Found user in session",    authUser);
        //angoose.getContext().setUser( session().$authenticatedUser );
        angoose.getContext().setPrincipal( new angoose.Principal( authUser.userId, authUser.roles) );
    }
    else{
        angoose.getContext().setPrincipal( new angoose.Principal( 'guest', 'guest' ));
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.preRedact" id="apidoc.element.angoose.angoose_authorization.preRedact">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preRedact
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function redact(next){
    logger().trace("in auth.preRedact");
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.angoose_mongoose" id="apidoc.module.angoose.angoose_mongoose">module angoose.angoose_mongoose</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.afterFormatError" id="apidoc.element.angoose.angoose_mongoose.afterFormatError">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>afterFormatError
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatError(next, invocation){
    var ex = invocation.packed.exception;
    console.log("Intercepting error", ex);
    // check if it's mongoose's model error
    var errors = toolbox.getter(ex , 'cause.errors');
    if( errors){
        // format model error
        var msg = '';
        Object.keys(errors).forEach(function(key){
            var errobj = errors[key];
            var m = errobj.message+"";
            msg = msg+m+" "
        });
        ex.message = msg;
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.config" id="apidoc.element.angoose.angoose_mongoose.config">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require("./test/server").startServer();
    });

    grunt.registerTask('autotest', 'watch and test', function(argPattern) {

        var watched= ["lib/**/*.js", "test/**/*.js", "models/**/*.js", "extensions/**/*.js"
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>('watch.autotest.files', watched);
        grunt.config('watch.autotest.tasks',  (argPattern? 'test:'+ argPattern: 'test'));
        grunt.task.run(argPattern? 'test:'+ argPattern: 'test');
        grunt.task.run('watch:autotest');

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.getContext" id="apidoc.element.angoose.angoose_mongoose.getContext">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require("./angoose").getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.getSchema" id="apidoc.element.angoose.angoose_mongoose.getSchema">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != 'function') continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == 'function'){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postExportModule" id="apidoc.element.angoose.angoose_mongoose.postExportModule">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postExportModule
        <span class="apidocSignatureSpan">( client, moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decorateMongooseSchema( client, moduleName){
    var model = angoose.module(moduleName);
    if(!model.schema || !model.schema.paths) return;
    logger().trace("Decorating mongoose model", moduleName);

    var schema = client.schemas[moduleName];
    // automatically publish these instance methods
    var instanceMethods = "save,remove,populate";
    instanceMethods.split(",").forEach(function(m){
        m = m.replace(/\s+/g, '');
        if(!schema.methods[m])
            schema.methods[m]= function remote(){};
    });

    // automatically publish these static methods
    var staticMethods = "populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update
,remove,count,geoNear,geoSearch,create";
    staticMethods.split(",").forEach(function(m){
        m = m.replace(/\s+/g, '');
        if(!schema.statics[m])
            schema.statics[m]= function remote(){};
    });

    schema.paths = traverse(model.schema.paths).map(function(item){
        if(!item) return;
        if(item.options &amp;&amp; typeof(item.options.type) === 'function' ){
            var fn = item.options.type;
            item.options.type = fn.name || fn.toString();
        }
        else if(typeof(item) == 'function')
            this.update( 'not-supported' );
        if(item.requiredValidator) delete item.requiredValidator;
        if(item.enumValidator) delete item.enumValidator;
        if(item.validators) delete item.validators;<span class="apidocCodeCommentSpan"> /**@todo validators are not supported yet*/
</span>    });
    schema.options = traverse( model.schema.options).clone();
//    filtPaths(schema);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postInvoke" id="apidoc.element.angoose.angoose_mongoose.postInvoke">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postInvoke
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postInvoke(next, invocation){
    var result = invocation.result;

    if(result &amp;&amp; result.exec &amp;&amp; (result instanceof angoose.getMongoose().Query) ){ // mongoose promise
        logger().debug("Return is mongoose query, call exec(). Conditions: ", result._conditions );
        result.exec( function(err, ret){
            if(err) return next(err);
            invocation.result = ret;
            next();
        });
        return;
    }

    function checkForModelError(result ){
        var target = invocation.static ? null : invocation.target;
        var err = ( target &amp;&amp; target.errors) || (result &amp;&amp; result.errors);
        if(err)
        {
            // temp error handling
            var msg = '';
            Object.keys(err).forEach(function (errItem) {
                msg += ex.message?"; ":"";
                msg += err[errItem].message;
            })
            msg = msg || err.toString();
            return msg;
        }
    }

    process.nextTick(function waitForModelError(){
<span class="apidocCodeCommentSpan">        /** the model error is emitted in next tick */
</span>        var ex = checkForModelError(result);
        if(ex){
            logger().debug("Detected model error", ex);
            return next(ex);
        }
        next();
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postPack" id="apidoc.element.angoose.angoose_mongoose.postPack">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postPack
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postPack(next, invocation){
    //console.log("In mongoose post pack", invocation)
    if(!invocation.redacted) return next();
    var type = getValueType(invocation.redacted);
    if(type) invocation.packed.datatype = type;
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postResolveTarget" id="apidoc.element.angoose.angoose_mongoose.postResolveTarget">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postResolveTarget
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postResolveTarget(next, invocation){
    if(!invocation.target || invocation.static || ! invocation.instance || !invocation.instance._id ) return next();
    logger().debug("postResolveTarget for mongoose models");

    var _id = invocation.instance._id;
    logger().trace("Loading pristine instance as base",invocation.clazz, _id);
    var modelClass = angoose.module(invocation.clazz);
    modelClass.findById(_id,   function mongoCallback(err, pristineInstance){
       if(err || !pristineInstance){
           logger().error("Failed to load model by id", _id);
           return next(err);
       }
       var pristineObject = pristineInstance.toObject();
       var schema = modelClass.schema;
       Object.keys(schema.paths).forEach(function(path){
           if (/^_/.test(path)) return;
           //var pathSchema = schema.paths[path];
           //var ref = schemaUtil.getReference(pathSchema);
           if (/^_/.test(path)) return;
           var newVal = toolbox.getter(invocation.instance, path);
           var oldVal  =  toolbox.getter(pristineObject, path);
           if(!_.isEqual(oldVal, newVal) &amp;&amp;  newVal !==  undefined ){<span class="apidocCodeCommentSpan"> /**@todo: empty value from client side doesn't mean set to
 empty, need to implement the $dirty, modified' */
</span>                if(newVal == '$CLEAR$') newVal = null;
                pristineInstance.set(path,newVal);
                logger().trace("seting", path, ": ",oldVal, " --&gt; ", newVal, " NOW dirty? ",  pristineInstance.isModified(path));
           }
       });
       invocation.target = pristineInstance;
       next();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>