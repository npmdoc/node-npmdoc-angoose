<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/tjworks/angoose"

    >angoose (v0.3.21)</a>
</h1>
<h4>Angoose is a Remote Method Invocation module that comes with built-in mongoose/angular support. Now you can call server side module in browser just like you're in the server side!</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose">module angoose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose">
            function <span class="apidocSignatureSpan"></span>angoose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle">
            function <span class="apidocSignatureSpan">angoose.</span>Bundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Context">
            function <span class="apidocSignatureSpan">angoose.</span>Context
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception">
            function <span class="apidocSignatureSpan">angoose.</span>Exception
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model">
            function <span class="apidocSignatureSpan">angoose.</span>Model
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline">
            function <span class="apidocSignatureSpan">angoose.</span>Pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Principal">
            function <span class="apidocSignatureSpan">angoose.</span>Principal
            <span class="apidocSignatureSpan">(userId, roles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable">
            function <span class="apidocSignatureSpan">angoose.</span>Remotable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService">
            function <span class="apidocSignatureSpan">angoose.</span>SampleService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUser
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service">
            function <span class="apidocSignatureSpan">angoose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo">
            function <span class="apidocSignatureSpan">angoose.</span>Todo
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.classy">
            function <span class="apidocSignatureSpan">angoose.</span>classy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.client">
            function <span class="apidocSignatureSpan">angoose.</span>client
            <span class="apidocSignatureSpan">(forceGenerate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.config">
            function <span class="apidocSignatureSpan">angoose.</span>config
            <span class="apidocSignatureSpan">(path, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.defer">
            function <span class="apidocSignatureSpan">angoose.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.execute">
            function <span class="apidocSignatureSpan">angoose.</span>execute
            <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.extension">
            function <span class="apidocSignatureSpan">angoose.</span>extension
            <span class="apidocSignatureSpan">(name, module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.generateClient">
            function <span class="apidocSignatureSpan">angoose.</span>generateClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getClass">
            function <span class="apidocSignatureSpan">angoose.</span>getClass
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getContext">
            function <span class="apidocSignatureSpan">angoose.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getLogger">
            function <span class="apidocSignatureSpan">angoose.</span>getLogger
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.getMongoose">
            function <span class="apidocSignatureSpan">angoose.</span>getMongoose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.hasModule">
            function <span class="apidocSignatureSpan">angoose.</span>hasModule
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.inContext">
            function <span class="apidocSignatureSpan">angoose.</span>inContext
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.init">
            function <span class="apidocSignatureSpan">angoose.</span>init
            <span class="apidocSignatureSpan">(app, conf, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.module">
            function <span class="apidocSignatureSpan">angoose.</span>module
            <span class="apidocSignatureSpan">(name, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.moduleNames">
            function <span class="apidocSignatureSpan">angoose.</span>moduleNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.rmiAccept">
            function <span class="apidocSignatureSpan">angoose.</span>rmiAccept
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.service">
            function <span class="apidocSignatureSpan">angoose.</span>service
            <span class="apidocSignatureSpan">(nameOpts, proto)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.setContext">
            function <span class="apidocSignatureSpan">angoose.</span>setContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.testContext">
            function <span class="apidocSignatureSpan">angoose.</span>testContext
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.user_model">
            function <span class="apidocSignatureSpan">angoose.</span>user_model
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Bundle.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Pipeline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Remotable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>SampleUser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>Service.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>angoose_authorization</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>angoose_mongoose</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>login_service</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>mongoose</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.</span>toolbox</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Bundle">module angoose.Bundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.Bundle">
            function <span class="apidocSignatureSpan">angoose.</span>Bundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.initHooks">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>initHooks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.post">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>post
            <span class="apidocSignatureSpan">(method, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.pre">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>pre
            <span class="apidocSignatureSpan">(method, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.typeOf">
            function <span class="apidocSignatureSpan">angoose.Bundle.</span>typeOf
            <span class="apidocSignatureSpan">(funcBody)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Bundle.prototype">module angoose.Bundle.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.configClient">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>configClient
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.createBundle">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>createBundle
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.exportModule">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModule
            <span class="apidocSignatureSpan">(client, moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.exportModules">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModules
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Bundle.prototype.generateClient">
            function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>generateClient
            <span class="apidocSignatureSpan">(clientData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Exception">module angoose.Exception</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception.Exception">
            function <span class="apidocSignatureSpan">angoose.</span>Exception
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Exception.super_">
            function <span class="apidocSignatureSpan">angoose.Exception.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Model">module angoose.Model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.Model">
            function <span class="apidocSignatureSpan">angoose.</span>Model
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.constructor">
            function <span class="apidocSignatureSpan">angoose.Model.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.extend">
            function <span class="apidocSignatureSpan">angoose.Model.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.getContext">
            function <span class="apidocSignatureSpan">angoose.Model.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.getSchema">
            function <span class="apidocSignatureSpan">angoose.Model.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Model.mixin">
            function <span class="apidocSignatureSpan">angoose.Model.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Model.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Pipeline">module angoose.Pipeline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.Pipeline">
            function <span class="apidocSignatureSpan">angoose.</span>Pipeline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline._lazySetupHooks">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>_lazySetupHooks
            <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.accept">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>accept
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.execute">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>execute
            <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.hook">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>hook
            <span class="apidocSignatureSpan">(name, fn, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.post">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>post
            <span class="apidocSignatureSpan">(name, isAsync, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.pre">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>pre
            <span class="apidocSignatureSpan">(name, isAsync, fn, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.removePost">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePost
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.removePre">
            function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePre
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.</span>hookables</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Pipeline.prototype">module angoose.Pipeline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.authorize">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>authorize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.formatError">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>formatError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.invoke">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>invoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.pack">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>pack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.redact">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>redact
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.resolveArguments">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveArguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Pipeline.prototype.resolveTarget">
            function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveTarget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>_posts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>_pres</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Remotable">module angoose.Remotable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.Remotable">
            function <span class="apidocSignatureSpan">angoose.</span>Remotable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.constructor">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.extend">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.getContext">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.isRemotableReserved">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>isRemotableReserved
            <span class="apidocSignatureSpan">(methodName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.mixin">
            function <span class="apidocSignatureSpan">angoose.Remotable.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Remotable.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Remotable.prototype">module angoose.Remotable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Remotable.prototype.getContext">
            function <span class="apidocSignatureSpan">angoose.Remotable.prototype.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleService">module angoose.SampleService</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.SampleService">
            function <span class="apidocSignatureSpan">angoose.</span>SampleService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.config">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.getContext">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.getSchema">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.listFavoriteDestinations">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>listFavoriteDestinations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testErrorBack">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testErrorBack
            <span class="apidocSignatureSpan">($callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testExecutionContext">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testExecutionContext
            <span class="apidocSignatureSpan">($callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleService.testPromiseReturn">
            function <span class="apidocSignatureSpan">angoose.SampleService.</span>testPromiseReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleService.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUser">module angoose.SampleUser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.SampleUser">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUser
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.checkExists">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>checkExists
            <span class="apidocSignatureSpan">(email)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.getSample">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>getSample
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.model">
            function <span class="apidocSignatureSpan">angoose.SampleUser.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.SampleUser.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUser.prototype">module angoose.SampleUser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.prototype.getFullname">
            function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>getFullname
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUser.prototype.setPassword">
            function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>setPassword
            <span class="apidocSignatureSpan">(newPassword, $context, $callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>schema</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.SampleUserGroup">module angoose.SampleUserGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup.SampleUserGroup">
            function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.SampleUserGroup.model">
            function <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Service">module angoose.Service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.Service">
            function <span class="apidocSignatureSpan">angoose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.constructor">
            function <span class="apidocSignatureSpan">angoose.Service.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.extend">
            function <span class="apidocSignatureSpan">angoose.Service.</span>extend
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.getContext">
            function <span class="apidocSignatureSpan">angoose.Service.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.getSchema">
            function <span class="apidocSignatureSpan">angoose.Service.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.mixin">
            function <span class="apidocSignatureSpan">angoose.Service.</span>mixin
            <span class="apidocSignatureSpan">(opts, target)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Service.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Service.prototype">module angoose.Service.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Service.prototype.toJSON">
            function <span class="apidocSignatureSpan">angoose.Service.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Service.prototype.</span>__classvars__</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.Todo">module angoose.Todo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo.Todo">
            function <span class="apidocSignatureSpan">angoose.</span>Todo
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.Todo.model">
            function <span class="apidocSignatureSpan">angoose.Todo.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.Todo.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.Todo.</span>modelName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.angoose_authorization">module angoose.angoose_authorization</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.beforeCreateBundle">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>beforeCreateBundle
            <span class="apidocSignatureSpan">( client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.config">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.getContext">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.getSchema">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.postAuthorize">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postAuthorize
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.postInvoke">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postInvoke
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.preAuthorize">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preAuthorize
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_authorization.preRedact">
            function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preRedact
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>_angoosemeta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.angoose_mongoose">module angoose.angoose_mongoose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.afterFormatError">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>afterFormatError
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.config">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.getContext">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.getSchema">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postExportModule">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postExportModule
            <span class="apidocSignatureSpan">( client, moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postInvoke">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postInvoke
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postPack">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postPack
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.angoose_mongoose.postResolveTarget">
            function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postResolveTarget
            <span class="apidocSignatureSpan">(next, invocation)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.classy">module angoose.classy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.classy.classy">
            function <span class="apidocSignatureSpan">angoose.</span>classy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.login_service">module angoose.login_service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.login_service.config">
            function <span class="apidocSignatureSpan">angoose.login_service.</span>config
            <span class="apidocSignatureSpan">(path, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.login_service.getContext">
            function <span class="apidocSignatureSpan">angoose.login_service.</span>getContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.login_service.getSchema">
            function <span class="apidocSignatureSpan">angoose.login_service.</span>getSchema
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.login_service.signin">
            function <span class="apidocSignatureSpan">angoose.login_service.</span>signin
            <span class="apidocSignatureSpan">(username, password, $callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.login_service.signout">
            function <span class="apidocSignatureSpan">angoose.login_service.</span>signout
            <span class="apidocSignatureSpan">( $callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.login_service.</span>_angoosemeta</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.toolbox">module angoose.toolbox</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.addHookPoints">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>addHookPoints
            <span class="apidocSignatureSpan">(clazz, hookables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.async">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>async
            <span class="apidocSignatureSpan">(fn, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.bindCallback">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>bindCallback
            <span class="apidocSignatureSpan">(scope, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.camelcase">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>camelcase
            <span class="apidocSignatureSpan">(name, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.decamelcase">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>decamelcase
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.exportModuleMethods">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>exportModuleMethods
            <span class="apidocSignatureSpan">(moduleName, mod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.getter">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>getter
            <span class="apidocSignatureSpan">(doc, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.merge">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>merge
            <span class="apidocSignatureSpan">(dst, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.methodType">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>methodType
            <span class="apidocSignatureSpan">(funcBody)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.parseDeclaredArguments">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>parseDeclaredArguments
            <span class="apidocSignatureSpan">(funcBody)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.patchMongoCallback">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>patchMongoCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.patchQ">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>patchQ
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.removeHookPoints">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>removeHookPoints
            <span class="apidocSignatureSpan">(clazz, hookables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.setter">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>setter
            <span class="apidocSignatureSpan">(doc, path, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.stringifySchema">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>stringifySchema
            <span class="apidocSignatureSpan">(schemaObj )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.toolbox.typeOf">
            function <span class="apidocSignatureSpan">angoose.toolbox.</span>typeOf
            <span class="apidocSignatureSpan">(funcBody)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.angoose.user_model">module angoose.user_model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.user_model.user_model">
            function <span class="apidocSignatureSpan">angoose.</span>user_model
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.angoose.user_model.model">
            function <span class="apidocSignatureSpan">angoose.user_model.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.user_model.</span>base</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.user_model.</span>collection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.user_model.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">angoose.user_model.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">angoose.user_model.</span>modelName</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose" id="apidoc.module.angoose">module angoose</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose" id="apidoc.element.angoose.angoose">
        function <span class="apidocSignatureSpan"></span>angoose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angoose(){
    return lookupOrRegister.apply(null, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle" id="apidoc.element.angoose.Bundle">
        function <span class="apidocSignatureSpan">angoose.</span>Bundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bundle(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&#x3e;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.<span class="apidocCodeKeywordSpan">Bundle</span>().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Context" id="apidoc.element.angoose.Context">
        function <span class="apidocSignatureSpan">angoose.</span>Context
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Context(properties){
    this.seqnum =  properties.seqnum || (++seqnum);
    var props = properties;

    this.request = props.request;
    this.response = props.response;


    // ** getRequest() **
    //
    // Returns the express request object
    this.getRequest = function(){
        return props.request;
    }

    // ** getResponse **
    //
    // Returns the express response object
    this.getResponse = function(){
        return props.response;
    }

    // ** getInvocation **
    //
    // Returns the invocation object associated with current context
    this.getInvocation = function(){
        return this.invocation;
    }

    this.setUser = function(user){
        this.user = user;
    }
    this.getUser = function(){
        return this.user;
    }

    this.setPrincipal = function(principal){
        props.principal = principal;
    }
    // not used yet
    this.getPrincipal = function(){
        if(props.principal) return props.principal;
        return new Principal();
    }

    this.toString = function(){
        return &#x22;[Context@&#x22;+ this.seqnum+&#x22;]&#x22;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

&#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#
x22;title&#x22;&#x3e;rmiAccept&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(req,res)&#x3c;/span&#x3e;{&#x3c;/span&#
x3e;

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; invocation = decode(req.body);
    invocation.method = req.params.method;  &#x3c;span class=&#x22;comment&#x22;&#x3e;/** method must be part of the path for routes
 permission etc */&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;comment&#x22;&#x3e;/** setting execution context */&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; ctx = &#x3c;span class=&#x22;keyword&#x22;&#x3e;new&#x3c;/span
&#x3e; angoose.<span class="apidocCodeKeywordSpan">Context</span>({request:req, response:res, session:req.session});
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; excutionStorage = storageFactory.createNamespace(&#x3c;span class
=&#x22;string&#x22;&#x3e;&#x22;angoose&#x22;&#x3c;/span&#x3e;);
    excutionStorage.run(&#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span
&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;()&#x3c;/span&#x3e;{&#x3c;/span&#x3e;
        logger.debug(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Setting execution context&#x22;&#x3c;/span&#x3e;);
        &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; sent = &#x3c;span class=&#x22;literal&#x22;&#x3e;false&#x3c
;/span&#x3e;;
        excutionStorage.set(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;context&#x22;&#x3c;/span&#x3e;, ctx);
        &#x3c;span class=&#x22;keyword&#x22;&#x3e;try&#x3c;/span&#x3e; {
            processInvocation(invocation, ctx, &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#
x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(ex, data)&#x3c;/span&#x3e;{&#x3c;/span&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Exception" id="apidoc.element.angoose.Exception">
        function <span class="apidocSignatureSpan">angoose.</span>Exception
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exception(err, name){
    if(err instanceof Error){
        this.message = err.message;
        this.name = name || err.name;
        require(&#x27;traverse&#x27;)(err).forEach(function(){
            if(this.circular) this.remove();
        })
        this.cause = err;
        //this.cause = err;
        //delete this.cause.domain;
    }
    else{
        this.message = err;
        this.name =  name || &#x27;&#x27;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model" id="apidoc.element.angoose.Model">
        function <span class="apidocSignatureSpan">angoose.</span>Model
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline" id="apidoc.element.angoose.Pipeline">
        function <span class="apidocSignatureSpan">angoose.</span>Pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Principal" id="apidoc.element.angoose.Principal">
        function <span class="apidocSignatureSpan">angoose.</span>Principal
        <span class="apidocSignatureSpan">(userId, roles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Principal = function (userId, roles){
    var user = {
        userId: userId,
        //username: username,
        roles: Array.isArray(roles)?roles: (roles?[roles]:undefined)
    }
    // ** getUsername() **
    //
    // get current logged in user&#x27;s name/login
    //this.getUsername = function(){ return user.username};

    // ** getRoles **
    //
    // get current logged in user&#x27;s roles, always returns an array
    this.getRoles = function(){ return user.roles || [] };

    // ** getUserId **
    //
    // get current logged in user&#x27;s ID
    this.getUserId = function(){ return user.userId};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function preAuth(next){
    logger().trace(&#x22;in preAuth&#x22;, session().$authenticatedUser);
    var authUser = session().$authenticatedUser;
    if(authUser){
        logger().trace(&#x22;Found user in session&#x22;,    authUser);
        //angoose.getContext().setUser( session().$authenticatedUser );
        angoose.getContext().setPrincipal( new angoose.<span class="apidocCodeKeywordSpan">Principal</span>( authUser.userId, authUser
.roles) );
    }
    else{
        angoose.getContext().setPrincipal( new angoose.Principal( &#x27;guest&#x27;, &#x27;guest&#x27; ));
    }
    next();
};
function logger(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable" id="apidoc.element.angoose.Remotable">
        function <span class="apidocSignatureSpan">angoose.</span>Remotable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Remotable = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService" id="apidoc.element.angoose.SampleService">
        function <span class="apidocSignatureSpan">angoose.</span>SampleService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SampleService = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser" id="apidoc.element.angoose.SampleUser">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUser
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup" id="apidoc.element.angoose.SampleUserGroup">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service" id="apidoc.element.angoose.Service">
        function <span class="apidocSignatureSpan">angoose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Service = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Todo" id="apidoc.element.angoose.Todo">
        function <span class="apidocSignatureSpan">angoose.</span>Todo
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.classy" id="apidoc.element.angoose.classy">
        function <span class="apidocSignatureSpan">angoose.</span>classy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classy = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.client" id="apidoc.element.angoose.client">
        function <span class="apidocSignatureSpan">angoose.</span>client
        <span class="apidocSignatureSpan">(forceGenerate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClient(forceGenerate){
    if(!angoose.initialized ||  forceGenerate)
        generateClient();
    return require(options[&#x27;client-file&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function preGen(next){

    next();
}

//angoose.module(&#x27;MyService&#x27;, MyService )
var myService = angoose.<span class="apidocCodeKeywordSpan">client</span>().module(&#x27;MyService&#x27;);

setupPermission();
it(&#x22;allowedOp should be denied to guest user&#x22;, function(done){
    myService.allowedOp(function(err, ret ){
       console.log(&#x22;allowedOp result&#x22;, err, ret)
       assert.equal(err,&#x27;Access Denied&#x27;);
       done();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.config" id="apidoc.element.angoose.config">
        function <span class="apidocSignatureSpan">angoose.</span>config
        <span class="apidocSignatureSpan">(path, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, val){
    if(!path) return options;<span class="apidocCodeCommentSpan"> /**@todo: probably a deep copy */
</span>    if(!angoose.initialized &#x26;&#x26; typeof(path) == &#x27;string&#x27;) throw &#x22;Cannot call config(&#x22; + path+&#x22;) before angoose is intialized&#x22;;
    //if(angoose.initialized &#x26;&#x26; typeof(conf) == &#x27;object&#x27;) throw &#x22;Cannot config Angoose after startup&#x22;;

    if(typeof (path) === &#x27;string&#x27;){
         if(val === undefined)
            return toolbox.getter(options, path);
         toolbox.setter(options, path, val);
    }

    if(typeof(path) === &#x27;object&#x27;){
        // deep merge
        options = toolbox.merge(options, path);

    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require(&#x22;./test/server&#x22;).startServer();
    });

    grunt.registerTask(&#x27;autotest&#x27;, &#x27;watch and test&#x27;, function(argPattern) {

        var watched= [&#x22;lib/**/*.js&#x22;, &#x22;test/**/*.js&#x22;, &#x22;models/**/*.js&#x22;, &#x22;extensions/**/*.js&#x22
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>(&#x27;watch.autotest.files&#x27;, watched);
        grunt.config(&#x27;watch.autotest.tasks&#x27;,  (argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;));
        grunt.task.run(argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;);
        grunt.task.run(&#x27;watch:autotest&#x27;);

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.defer" id="apidoc.element.angoose.defer">
        function <span class="apidocSignatureSpan">angoose.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer(){
    return Q.defer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// angular http ignores all key names starting with $, this will break the mongo query
data = encode$(data);
 console.log(&#x22;****** BEGIN Client Call #&#x22;, data.seqnumber,modelName, methodName, data);
var http = depends[&#x27;http&#x27;];
var theQ = depends[&#x27;promise&#x27;];
if (!http || !theQ) throw &#x22;Missing http and/or Q dependencies&#x22;;
var deferred = theQ.<span class="apidocCodeKeywordSpan">defer</span>();
var ret = http.post((getConfigs().urlPrefix || &#x27;/angoose&#x27;) + &#x22;/rmi/&#x22; + modelName + &#x22;/&#x22; + methodName
, data);
ret.done(function(retdata) {
     console.log(&#x22;****** END Client Call #&#x22;, data.seqnumber, &#x22; result:&#x22;, retdata);
    var val = undefined;
    //@todo construct object, ret value types:  1) model data, 2) list of model data, 3) String, 4) object
    if (retdata &#x26;&#x26; retdata.retval  &#x26;&#x26; ( retdata.datatype ==&#x27;model&#x27; || retdata.datatype ==&#x27;models
&#x27;)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.execute" id="apidoc.element.angoose.execute">
        function <span class="apidocSignatureSpan">angoose.</span>execute
        <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (ctx, invocation, callback){
        [&#x27;allowed&#x27;, &#x27;target&#x27;, &#x27;arguments&#x27;,&#x27;result&#x27;,&#x27;redacted&#x27;].forEach(function(key){
            delete invocation[key];
        });

        var dmain = domain.create();
        dmain.context = ctx;
        //var excutionStorage = storageFactory.createNamespace(&#x22;angoose&#x22;);
<span class="apidocCodeCommentSpan">        /** here comes the main body of the processing */
</span>        dmain.run(function(){
                var pipeline = new Pipeline();
                var seqnum = invocation.seqnumber;
                var sent = false;
                logger.debug(&#x22;------ BEGIN RMI #&#x22;, seqnum, invocation.clazz, invocation.method );
                logger.trace(&#x22;Invocation object: &#x22;,invocation);
                //invocation.method = req.params.method;  /** method must be part of the path for routes permission etc */
                ctx.seqnum = seqnum;
                ctx.invocation = invocation;

                function handleError(err, exName){
                    if(sent){
                        logger.debug(&#x22;Response already sent&#x22;)
                        return;
                    }
                    /**@todo: err may cause Circular issue when converting to JSON */
                    var ex = new Exception(err, exName);
                    invocation.exception = ex;

                    pipeline.formatError(invocation, function(er){
                        logger.debug(&#x22;====== END RMI with Error  #&#x22;, seqnum,  ex);
                        callback(invocation.packed);
                        sent  = true;
                    });
                }
                dmain.on(&#x27;error&#x27;,  function uncaught(ex){
                    logger.error(&#x22;Uncaught error in invocation #&#x22;+seqnum, ex);
                    /**@todo: restart server if too many errors */
                    handleError(  &#x22;Unexpected Server Error&#x22;, &#x27;RuntimeError&#x27;);
                });

                /** setting execution context */
                var sent = false;

                var modelName = invocation.clazz;
                var seqnum = invocation.seqnumber;
                //excutionStorage.set(&#x22;context&#x22;, ctx);
                pipeline.authorize(invocation,   function(err){
                    if(err) return handleError(err);
                    if(! invocation.allowed) return handleError(&#x22;Access Denied&#x22;, &#x22;AuthError&#x22;);

                    pipeline.resolveTarget(invocation,   function(err){
                        if(err) return handleError(err);

                        if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);

                        pipeline.resolveArguments(invocation,function(err){
                            if(err) return handleError(err);

                            if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
                            pipeline.invoke(invocation, function(ex){

                                if(ex) return handleError(ex);
                                pipeline.redact(invocation, function(err){
                                    if(err) return handleError(err);
                                    pipeline.pack(invocation, function(err){
                                        if(err) return handleError(err);
                                        //res.send(200, packedData);
                                        callback(invocation.packed);
                                        sent = true;
                                        logger.debug(&#x22;====== END RMI Succeeded #&#x22;, seqnum);
                                        if(Array.isArray(invocation.packed &#x26;&#x26; invocation.packed.retval) &#x26;&#x26; invocation.packed.retval
.length&#x3e;0){
                                            logger.trace(&#x22;Response is an array with length:&#x22;,  invocation.packed.retval.length, &#x22;
First element:&#x22;,invocation.packed.retval[0] ); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        });/** end context closure */
}

Pipeline.accept = function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.<span class="apidocCodeKeywordSpan">execute</span>(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.extension" id="apidoc.element.angoose.extension">
        function <span class="apidocSignatureSpan">angoose.</span>extension
        <span class="apidocSignatureSpan">(name, module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerExtension(name, module){
     if( typeof(name) ==&#x27;object&#x27; )
        name.isExtension = true;
     else
        name = {name: name, isExtension:true}
     return registerClass(name,module);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
preAuthorize: preAuth,
postAuthorize: postAuth,
preRedact: redact,
postInvoke: postInvoke,
beforeCreateBundle: beforeCreateBundle
};

module.exports = angoose.<span class="apidocCodeKeywordSpan">extension</span>(&#x27;AngooseAuthorization&#x27;,  authExt);

function preAuth(next){
logger().trace(&#x22;in preAuth&#x22;, session().$authenticatedUser);
var authUser = session().$authenticatedUser;
if(authUser){
    logger().trace(&#x22;Found user in session&#x22;,    authUser);
    //angoose.getContext().setUser( session().$authenticatedUser );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.generateClient" id="apidoc.element.angoose.generateClient">
        function <span class="apidocSignatureSpan">angoose.</span>generateClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateClient(){
    logger.debug(&#x22;Generating angoose client file: &#x22;);
    var bundle = new Bundle();
    var client = {};
    bundle.generateClient(client);
    var filename = angoose.config()[&#x27;client-file&#x27;];
    writeToFile(filename, client.source)
    //compressFile(filename, client.source);
    logger.info(&#x22;Generated  angoose client file: &#x22;, filename);
    return client.source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ** geneateClient() **
//
// Generates the client file to be served as the contents of resource `/angoose/angoose-client.js`
function generateClient(){
    logger.debug(&#x22;Generating angoose client file: &#x22;);
    var bundle = new Bundle();
    var client = {};
    bundle.<span class="apidocCodeKeywordSpan">generateClient</span>(client);
    var filename = angoose.config()[&#x27;client-file&#x27;];
    writeToFile(filename, client.source)
    //compressFile(filename, client.source);
    logger.info(&#x22;Generated  angoose client file: &#x22;, filename);
    return client.source;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getClass" id="apidoc.element.angoose.getClass">
        function <span class="apidocSignatureSpan">angoose.</span>getClass
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClass(name){
    name = toolbox.camelcase(name);
    if(!beans[name]) throw &#x22;Class &#x27;&#x22;+ name+&#x22;&#x27; is not found. Check log to see if class is loaded successfully &#x22;
    return beans[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }
   console.log(&#x22;Bootstraping angoose-client&#x22;);

// ** getClass **
//
// Get the model class, you may call static method such as findXXX or create new model instance
//
//      var SampleUser = angoose.<span class="apidocCodeKeywordSpan">getClass</span>(&#x27;SampleUser&#x27;);
//      SampleUser.findOne();
//      var u = new SampleUser();
//

var counterBase = Math.round(Math.random() * 10000) * 10000;
var nextCounter = function() {
    return counterBase++;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getContext" id="apidoc.element.angoose.getContext">
        function <span class="apidocSignatureSpan">angoose.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContext(){

    if(!domain.active || !domain.active.context){
        if(this.mockContext) return this.mockContext

        logger.error(&#x22;getContext called but no active domain&#x22;, domain.active);
        logger.error(&#x22;Caller is &#x22;,   arguments.callee &#x26;&#x26; arguments.callee.caller &#x26;&#x26; arguments.callee.caller.name, arguments.callee
 &#x26;&#x26; arguments.callee.caller );
        throw &#x22;Context not available. This may happen if the code was not originated by Angoose&#x22;;
    }

    return domain.active.context;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getLogger" id="apidoc.element.angoose.getLogger">
        function <span class="apidocSignatureSpan">angoose.</span>getLogger
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name){
    name = name || &#x27;angoose&#x27;;
    return require(&#x22;log4js&#x22;).getLogger(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      &#x3c;div class=&#x22;pilwrap &#x22;&#x3e;
        &#x3c;a class=&#x22;pilcrow&#x22; href=&#x22;#section-1&#x22;&#x3e;&#x26;#182;&#x3c;/a&#x3e;
      &#x3c;/div&#x3e;

    &#x3c;/div&#x3e;

    &#x3c;div class=&#x22;content&#x22;&#x3e;&#x3c;div class=&#x27;highlight&#x27;&#x3e;&#x3c;pre&#x3e;&#x3c;span class=&#x22;keyword
&#x22;&#x3e;var&#x3c;/span&#x3e; logger = require(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;log4js&#x22;&#x3c;/span&#x3e;).<
span class="apidocCodeKeywordSpan">getLogger</span>(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;angoose&#x22;&#x3c;/span&#x3e
;);&#x3c;/pre&#x3e;&#x3c;/div&#x3e;&#x3c;/div&#x3e;

&#x3c;/li&#x3e;


&#x3c;li id=&#x22;section-2&#x22;&#x3e;
    &#x3c;div class=&#x22;annotation&#x22;&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.getMongoose" id="apidoc.element.angoose.getMongoose">
        function <span class="apidocSignatureSpan">angoose.</span>getMongoose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMongoose(){
    angoose.mongoose = angoose.mongoose || options.mongoose;
    if(!angoose.mongoose){
        try{
            angoose.mongoose =  module.parent.require(&#x27;mongoose&#x27;);
            logger.debug(&#x22;Required mongoose from parent&#x22;)
        }
        catch(err){
            logger.debug(&#x22;No mongoose in parent module&#x22;);
            angoose.mongoose = require(&#x22;mongoose&#x22;);
        }

    }
    return angoose.mongoose;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               var path = category +&#x22;.&#x22; +  toolbox.camelcase(group);
               var field = {};
               field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
               authSchema.add(field);
           }
        };
    });
    var mongooseModel =  angoose.<span class="apidocCodeKeywordSpan">getMongoose</span>().modelNames().indexOf(MODEL_NAME)&#x3e;=
0? angoose.getMongoose().model(MODEL_NAME):angoose.getMongoose().model(MODEL_NAME, authSchema) ;
    var permModule = angoose.module(MODEL_NAME, mongooseModel);
    new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods(MODEL_NAME, permModule);
    logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

    setupInitialRoles();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.hasModule" id="apidoc.element.angoose.hasModule">
        function <span class="apidocSignatureSpan">angoose.</span>hasModule
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasModule(name){
    return beans[name] ? true : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.inContext" id="apidoc.element.angoose.inContext">
        function <span class="apidocSignatureSpan">angoose.</span>inContext
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inContext(fn){
<span class="apidocCodeCommentSpan">    /** there is a known issue with CLS that it does not work with MongoDB,
     * needs to bind the callback with the CLS context
     * https://github.com/othiym23/node-continuation-local-storage/issues/6
     * */
</span>    if(domain.active) return domain.active.bind(fn);
    return fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        done();
   });
});
testSchema.pre(&#x27;save&#x27;, true, function(next, done){
   next();
   angoose.getContext()
   console.log(&#x22;CONTEXT 3 OK&#x22;  );
   angoose(&#x27;TestUser&#x27;).findOne({x:2},   angoose.<span class="apidocCodeKeywordSpan">inContext</span>( function(err, re
){
        angoose.getContext()
        console.log(&#x22;CONTEXT 3.1 OK&#x22;);
        done();
   }));
});
angoose.module(&#x27;TestUser&#x27;, mongoose.model(&#x27;TestUser&#x27;, testSchema));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.init" id="apidoc.element.angoose.init">
        function <span class="apidocSignatureSpan">angoose.</span>init
        <span class="apidocSignatureSpan">(app, conf, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init(app, conf, force) {
    if(this.initialized &#x26;&#x26; !force) return;

    //beans = {};
<span class="apidocCodeCommentSpan">    /** configurations*/
</span>    initialConfig(conf);

    logger.info(&#x22;Angoose Initialization Start&#x22;);
    logger.trace(&#x22;Init options:&#x22;, conf);

    /** connect to Mongo if necessary */
    connectMongo(options);

    /** register initial hooks */
    //registerHooks();

    /** pre-load models/services from directories */
    harvestModules(options);

    /** plugin extensions */
    hookupExtensions();

    /** build client side schemas */
    generateClient();

    /** configure the routes for handling RMI and client loading*/
    /**@todo: middleware*/
    configureRoutes(app, options);

    logger.info(&#x22;Angoose Initialization Complete&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// ** angoose **
//
//  You may require `angoose` client as an injectable
//
angularModule.factory(&#x27;angoose&#x27;, function($http, $q){
        var myQ = addDoneMethod($q);
        AngooseClient.<span class="apidocCodeKeywordSpan">init</span>({
            http:angularHttpWrapper($http, myQ),
            promise: myQ
        });
        return AngooseClient;
})
function factoryFunc(modelName){
    console.log(&#x22;Create factory for model &#x22;+ modelName)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.module" id="apidoc.element.angoose.module">
        function <span class="apidocSignatureSpan">angoose.</span>module
        <span class="apidocSignatureSpan">(name, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupOrRegister(name, target){
    if(arguments.length == 0) return null;
    if(arguments.length == 1) return getClass(name);
    if(arguments.length == 2) return registerClass(name, target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

/****** Angular Adapter for Angoose Client *******/
// Angular client for Angoose automatically register the model and service classes as angular injectables.
// For instance, with the `SampleUser` model, you can inject in your controller:
//
//      angular.<span class="apidocCodeKeywordSpan">module</span>(&#x27;myapp&#x27;, [&#x27;angoose.client&#x27;])
//            .controller(&#x27;MyCtroller&#x27;, function($scope, SampleUser){
//              $scope.users = SampleUser.$query({&#x27;status&#x27;:&#x27;active&#x27;});
//        })
//
(function(){
if(typeof angular ==&#x27;undefined&#x27;){
    console.log(&#x22;No angular&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.moduleNames" id="apidoc.element.angoose.moduleNames">
        function <span class="apidocSignatureSpan">angoose.</span>moduleNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moduleNames(){
    return Object.keys(beans);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.exportModules = function(client){
 invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, client);

 logger.debug(&#x22;Exporting all modules&#x22;);
 client.schemas = client.schemas || {};
 var me = this;

 var names = angoose().<span class="apidocCodeKeywordSpan">moduleNames</span>();
 var total = names &#x26;&#x26; names.length;
 if(!total) return;

 names.forEach(function(moduleName){
     var mod = angoose().getClass(moduleName);
     if(mod.config &#x26;&#x26; mod.config(&#x22;visibility&#x22;) === &#x27;local&#x27;) return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.rmiAccept" id="apidoc.element.angoose.rmiAccept">
        function <span class="apidocSignatureSpan">angoose.</span>rmiAccept
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.execute(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           if(require(&#x22;fs&#x22;).existsSync(ROOT+&#x22;/lib/angoose.js&#x22;))
                angoose = require(ROOT+&#x22;/lib/angoose&#x22;);
           else {
                angoose = require(&#x22;angoose&#x22;);
           }


           angoose.<span class="apidocCodeKeywordSpan">rmiAccept</span>(request, response);
           return deferred.promise;
        }
        return mock
    }

    module.exports = AngooseClient;
})()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.service" id="apidoc.element.angoose.service">
        function <span class="apidocSignatureSpan">angoose.</span>service
        <span class="apidocSignatureSpan">(nameOpts, proto)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function service(nameOpts, proto){
    logger.debug(&#x22;creating service &#x22;, nameOpts, typeof(proto));
    var opts = typeof(nameOpts) == &#x27;string&#x27;? {name: nameOpts}: nameOpts;
    if(!opts.name) throw &#x22;Service name must be provided.&#x22;;
    proto = proto || {};
    return angoose.Service.extend(proto, opts );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Unfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to
 make those modules with database/filesystem or other
external IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are
good usa case of Angoose modules.

Only modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:

- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.model()` call.
- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.<span class="apidocCodeKeywordSpan
">service</span>() is still supported and does same thing)

And for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.

There are a couple of exmaples under `angoose/models` directory for reference.

#### About Mongoose Models
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.setContext" id="apidoc.element.angoose.setContext">
        function <span class="apidocSignatureSpan">angoose.</span>setContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setContext(ctx){
    this.mockContext = ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.testContext" id="apidoc.element.angoose.testContext">
        function <span class="apidocSignatureSpan">angoose.</span>testContext
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testContext(name){

    if(!domain.active){
        domainLogger.debug(&#x22;-------------------------------------- TEST-CONTEXT &#x22;, name, &#x22;NO ACTIVE DOMAIN&#x22;);
        return;
    }
    if(!domain.active.context){
        domainLogger.debug(&#x22;---------------------------------------TEST-CONTEXT &#x22;, name, &#x22;NO CONTEXT in active domain&#x22;);
        return;
    }
    domainLogger.debug(&#x22;-------------------------------------- TEST-CONTEXT &#x22;, name, &#x22;  OK &#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

});
describe(&#x22;Context with nested mongoose callback&#x22;, function(){
it(&#x22;Nested callback test&#x22;, function(done){
    var TestUser = angoose.client(true).module(&#x22;SampleUser&#x22;);
    TestUser.findOne({x:100}, function(err, u){
        angoose.<span class="apidocCodeKeywordSpan">testContext</span>(&#x22;Callback 1&#x22;)
        mongoose.model(&#x22;SampleUser&#x22;).findOne({x:200}, function(err, u){
            angoose.testContext(&#x22;Callback 2&#x22;)
            angoose.getContext();
            assert(!err);
            mongoose.model(&#x22;SampleUser&#x22;).findOne({x:300}, function(err, u){
                angoose.testContext(&#x22;Callback 3&#x22;)
                angoose.getContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.user_model" id="apidoc.element.angoose.user_model">
        function <span class="apidocSignatureSpan">angoose.</span>user_model
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Bundle" id="apidoc.module.angoose.Bundle">module angoose.Bundle</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Bundle.Bundle" id="apidoc.element.angoose.Bundle.Bundle">
        function <span class="apidocSignatureSpan">angoose.</span>Bundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bundle(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&#x3e;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.<span class="apidocCodeKeywordSpan">Bundle</span>().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.initHooks" id="apidoc.element.angoose.Bundle.initHooks">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>initHooks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initHooks(){
    hooks.pre = {};
    hooks.post = {};
    [&#x27;generateClient&#x27;,&#x27;configClient&#x27;,&#x27;exportModules&#x27;,&#x27;exportModule&#x27;,&#x27;createBundle&#x27;].forEach(function(name){
        hooks.pre[name] = [];
        hooks.post[name] = [];
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function noop(){};


function hookupExtensions(){
logger.debug(&#x22;Searching Extensions in Modules&#x22;);
toolbox.removeHookPoints(Pipeline);
Bundle.<span class="apidocCodeKeywordSpan">initHooks</span>();
Object.keys(beans).forEach(function(bname){
    var bean = beans[bname];
    if(!bean._angoosemeta.isExtension) return;
    logger.debug(&#x22;Loading extension&#x22;, bname);
    bean.config(&#x27;visibility&#x27;, false);
    registerHook(bean, bname);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.post" id="apidoc.element.angoose.Bundle.post">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>post
        <span class="apidocSignatureSpan">(method, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (method, func){
    return addHook(&#x27;post&#x27;, method, func)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// angular http ignores all key names starting with $, this will break the mongo query
data = encode$(data);
 console.log(&#x22;****** BEGIN Client Call #&#x22;, data.seqnumber,modelName, methodName, data);
var http = depends[&#x27;http&#x27;];
var theQ = depends[&#x27;promise&#x27;];
if (!http || !theQ) throw &#x22;Missing http and/or Q dependencies&#x22;;
var deferred = theQ.defer();
var ret = http.<span class="apidocCodeKeywordSpan">post</span>((getConfigs().urlPrefix || &#x27;/angoose&#x27;) + &#x22;/rmi/&#x22
; + modelName + &#x22;/&#x22; + methodName, data);
ret.done(function(retdata) {
     console.log(&#x22;****** END Client Call #&#x22;, data.seqnumber, &#x22; result:&#x22;, retdata);
    var val = undefined;
    //@todo construct object, ret value types:  1) model data, 2) list of model data, 3) String, 4) object
    if (retdata &#x26;&#x26; retdata.retval  &#x26;&#x26; ( retdata.datatype ==&#x27;model&#x27; || retdata.datatype ==&#x27;models
&#x27;)) {

        if(retdata.datatype == &#x27;model&#x27;){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.pre" id="apidoc.element.angoose.Bundle.pre">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>pre
        <span class="apidocSignatureSpan">(method, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pre = function (method, func){
    return addHook(&#x27;pre&#x27;, method, func)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getModelSchema(){
    var schema =  new angoose.getMongoose().Schema({
         role: {type:String, label:&#x27;Role&#x27;, required:true, tags:[&#x27;default-list&#x27;], unique:true },
         desc: {type:String, label:&#x27;Description&#x27;,tags:[&#x27;default-list&#x27;]}
    }, {collection: COLLECTION_NAME});

    schema.<span class="apidocCodeKeywordSpan">pre</span>(&#x27;save&#x27;, function(next){
       cached =  null; // invalidate the cache
       next();
    });

    return schema;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.typeOf" id="apidoc.element.angoose.Bundle.typeOf">
        function <span class="apidocSignatureSpan">angoose.Bundle.</span>typeOf
        <span class="apidocSignatureSpan">(funcBody)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeOf = function (funcBody){
    funcBody = typeof(funcBody) == &#x27;function&#x27; ? funcBody.toString() : funcBody;
    if(funcBody.indexOf(&#x22;function&#x22;)!=0) return &#x22;unknown&#x22;;
    var matcher = FunctionNamePattern.exec(funcBody);
    return matcher? matcher[1]: &#x27;remote&#x27;; //default is remote
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.stringifySchema = function(schemaObj ){
//logger.trace(&#x22;stringifySchema&#x22;, moduleName);
var funcs = {};
function funcStringifier(key, value) {
    if (typeof value !== &#x27;function&#x27;) return value;
    var body =  value.toString();
    var funcType = exports.<span class="apidocCodeKeywordSpan">typeOf</span>(body);
    if(!funcType) return; //&#x27;not-available&#x27;;
    if(funcType.indexOf(&#x22;local&#x22;)&#x3e;=0) return &#x27;This method can be invoked from server side only&#x27;;

    if(funcType.indexOf(&#x22;portable&#x22;)&#x3e;=0){
        /** the function can be executed client side */
       return body;
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Bundle.prototype" id="apidoc.module.angoose.Bundle.prototype">module angoose.Bundle.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.configClient" id="apidoc.element.angoose.Bundle.prototype.configClient">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>configClient
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configClient = function (client){
    logger.debug(&#x22;Setup client options&#x22;);
    client.options = client.options || {};

    var angooseOpts = angoose().config();
    var clientOptionNames = [&#x27;url-prefix&#x27;, &#x27;logging&#x27;];

    _.extend(client.options, angooseOpts.client);
    client.options.urlPrefix = angooseOpts[&#x27;url-prefix&#x27;];

    clientOptionNames.forEach(function(key){
        client.options[key] = angooseOpts[key];
    });
    //client.options.logging = angoose().config()[&#x27;logging&#x27;] || &#x27;INFO&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 */
proto.generateClient = function(clientData){
invokeHook(&#x27;pre&#x27;, &#x27;generateClient&#x27;, clientData);
// client side configurations

invokeHook(&#x27;pre&#x27;, &#x27;configClient&#x27;, clientData);
this.<span class="apidocCodeKeywordSpan">configClient</span>(clientData);
invokeHook(&#x27;post&#x27;, &#x27;configClient&#x27;, clientData);

invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, clientData);
this.exportModules(clientData);
invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, clientData);

invokeHook(&#x27;pre&#x27;, &#x27;createBundle&#x27;, clientData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.createBundle" id="apidoc.element.angoose.Bundle.prototype.createBundle">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>createBundle
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBundle = function (client){
    logger.debug(&#x22;Bundle client files&#x22;);

    if(client.source) return; // already generated source
    var jsonSchemas = toolbox.stringifySchema( client.schemas );
    var template = path.resolve(__dirname , &#x22;client/angoose-client.js&#x22;);
    var content = fs.readFileSync(template , &#x27;ascii&#x27;);
    content = content.replace(&#x22;<span class="apidocCodeCommentSpan">/**SCHEMA_PLACEHOLDER*/&#x22;,  jsonSchemas);
    content = content.replace(&#x22;/**CONFIG_PLACEHOLDER*/&#x22;, JSON.stringify( client.options ));

    /**  include client specific extensions*/
</span>    var clientModuleFile = path.resolve(__dirname , &#x22;client/angoose-angular.js&#x22;);
    content += fs.readFileSync(clientModuleFile, &#x27;ascii&#x27;);

    clientModuleFile = path.resolve(__dirname , &#x22;client/angoose-jquery.js&#x22;);
    content += fs.readFileSync(clientModuleFile, &#x27;ascii&#x27;);

    clientModuleFile = path.resolve(__dirname , &#x22;client/angoose-node.js&#x22;);
    content += fs.readFileSync(clientModuleFile, &#x27;ascii&#x27;);

    client.source = content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    invokeHook(&#x27;post&#x27;, &#x27;configClient&#x27;, clientData);

    invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, clientData);
    this.exportModules(clientData);
    invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, clientData);

    invokeHook(&#x27;pre&#x27;, &#x27;createBundle&#x27;, clientData);
    this.<span class="apidocCodeKeywordSpan">createBundle</span>(clientData);
    invokeHook(&#x27;post&#x27;, &#x27;createBundle&#x27;, clientData);

    invokeHook(&#x27;post&#x27;, &#x27;generateClient&#x27;, clientData);

};
//@tood: ,serializeModules,serializeModule,prepareSchema
// Bundle.hookables = &#x27;generateClient,configClient,exportModules,exportModule,createBundle&#x27;.split(&#x22;,&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.exportModule" id="apidoc.element.angoose.Bundle.prototype.exportModule">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModule
        <span class="apidocSignatureSpan">(client, moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportModule = function (client, moduleName){
    invokeHook(&#x27;pre&#x27;, &#x27;exportModule&#x27;, client, moduleName);

    logger.trace(&#x22;in exportModule&#x22;, moduleName);
    if(client.schemas[moduleName]) return; // already handled
    var mod = angoose().module(moduleName);
    var schema = toolbox.exportModuleMethods(moduleName, mod);
    if(!schema) logger.error(&#x22;Module&#x22;, moduleName, &#x22; has no schema, export failed&#x22;, mod);
    else client.schemas[moduleName] = schema;

    invokeHook(&#x27;post&#x27;, &#x27;exportModule&#x27;, client, moduleName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&#x3e;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.Bundle().<span class="apidocCodeKeywordSpan">exportModule</span>(client, MODEL_NAME); // toolbox.exportModuleMethods
(MODEL_NAME, permModule);
logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.exportModules" id="apidoc.element.angoose.Bundle.prototype.exportModules">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>exportModules
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportModules = function (client){
    invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, client);

    logger.debug(&#x22;Exporting all modules&#x22;);
    client.schemas = client.schemas || {};
    var me = this;

    var names = angoose().moduleNames();
    var total = names &#x26;&#x26; names.length;
    if(!total) return;

    names.forEach(function(moduleName){
        var mod = angoose().getClass(moduleName);
        if(mod.config &#x26;&#x26; mod.config(&#x22;visibility&#x22;) === &#x27;local&#x27;) return;

        me.exportModule(client, moduleName);

    }) ;

    invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, client);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// client side configurations

invokeHook(&#x27;pre&#x27;, &#x27;configClient&#x27;, clientData);
this.configClient(clientData);
invokeHook(&#x27;post&#x27;, &#x27;configClient&#x27;, clientData);

invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, clientData);
this.<span class="apidocCodeKeywordSpan">exportModules</span>(clientData);
invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, clientData);

invokeHook(&#x27;pre&#x27;, &#x27;createBundle&#x27;, clientData);
this.createBundle(clientData);
invokeHook(&#x27;post&#x27;, &#x27;createBundle&#x27;, clientData);

invokeHook(&#x27;post&#x27;, &#x27;generateClient&#x27;, clientData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Bundle.prototype.generateClient" id="apidoc.element.angoose.Bundle.prototype.generateClient">
        function <span class="apidocSignatureSpan">angoose.Bundle.prototype.</span>generateClient
        <span class="apidocSignatureSpan">(clientData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateClient = function (clientData){
    invokeHook(&#x27;pre&#x27;, &#x27;generateClient&#x27;, clientData);
    // client side configurations

    invokeHook(&#x27;pre&#x27;, &#x27;configClient&#x27;, clientData);
    this.configClient(clientData);
    invokeHook(&#x27;post&#x27;, &#x27;configClient&#x27;, clientData);

    invokeHook(&#x27;pre&#x27;, &#x27;exportModules&#x27;, clientData);
    this.exportModules(clientData);
    invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, clientData);

    invokeHook(&#x27;pre&#x27;, &#x27;createBundle&#x27;, clientData);
    this.createBundle(clientData);
    invokeHook(&#x27;post&#x27;, &#x27;createBundle&#x27;, clientData);

    invokeHook(&#x27;post&#x27;, &#x27;generateClient&#x27;, clientData);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ** geneateClient() **
//
// Generates the client file to be served as the contents of resource `/angoose/angoose-client.js`
function generateClient(){
    logger.debug(&#x22;Generating angoose client file: &#x22;);
    var bundle = new Bundle();
    var client = {};
    bundle.<span class="apidocCodeKeywordSpan">generateClient</span>(client);
    var filename = angoose.config()[&#x27;client-file&#x27;];
    writeToFile(filename, client.source)
    //compressFile(filename, client.source);
    logger.info(&#x22;Generated  angoose client file: &#x22;, filename);
    return client.source;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Exception" id="apidoc.module.angoose.Exception">module angoose.Exception</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Exception.Exception" id="apidoc.element.angoose.Exception.Exception">
        function <span class="apidocSignatureSpan">angoose.</span>Exception
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Exception(err, name){
    if(err instanceof Error){
        this.message = err.message;
        this.name = name || err.name;
        require(&#x27;traverse&#x27;)(err).forEach(function(){
            if(this.circular) this.remove();
        })
        this.cause = err;
        //this.cause = err;
        //delete this.cause.domain;
    }
    else{
        this.message = err;
        this.name =  name || &#x27;&#x27;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Exception.super_" id="apidoc.element.angoose.Exception.super_">
        function <span class="apidocSignatureSpan">angoose.Exception.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Model" id="apidoc.module.angoose.Model">module angoose.Model</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Model.Model" id="apidoc.element.angoose.Model.Model">
        function <span class="apidocSignatureSpan">angoose.</span>Model
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.constructor" id="apidoc.element.angoose.Model.constructor">
        function <span class="apidocSignatureSpan">angoose.Model.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.extend" id="apidoc.element.angoose.Model.extend">
        function <span class="apidocSignatureSpan">angoose.Model.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace(&#x22;Extending from &#x22;,   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == &#x27;function&#x27;){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require(&#x22;./angoose&#x22;).registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
    var myQ = angular.<span class="apidocCodeKeywordSpan">extend</span>({}, $q)
    myQ.defer = function(){
        var out = $q.defer.apply($q, arguments);
        if(out.promise.done) return out;
        out.promise.done = function(successCallback, errorCallback){
            out.promise.then(successCallback, errorCallback);
        }
        return out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.getContext" id="apidoc.element.angoose.Model.getContext">
        function <span class="apidocSignatureSpan">angoose.Model.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.getSchema" id="apidoc.element.angoose.Model.getSchema">
        function <span class="apidocSignatureSpan">angoose.Model.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSchema = function (){
    return this.schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Model.mixin" id="apidoc.element.angoose.Model.mixin">
        function <span class="apidocSignatureSpan">angoose.Model.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || &#x27;Service&#x27;;
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == &#x27;Model&#x27;)
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opts.baseClass = &#x27;Model&#x27;;
    else if(claz instanceof getMongoose().Schema){
        opts.baseClass = &#x27;Model&#x27;;
        claz = getMongoose().model(className, claz);
    }
    else
        opts.baseClass = &#x27;Service&#x27;;
    angoose.Remotable.<span class="apidocCodeKeywordSpan">mixin</span>(opts, claz);
}
_.extend(claz._angoosemeta, nameOrOpts);

beans[className] = claz;
//if(!nameOrOpts.isExtension)
    logger.debug(&#x22;Registered module&#x22;, claz._angoosemeta.baseClass, className);
return claz;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Pipeline" id="apidoc.module.angoose.Pipeline">module angoose.Pipeline</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Pipeline.Pipeline" id="apidoc.element.angoose.Pipeline.Pipeline">
        function <span class="apidocSignatureSpan">angoose.</span>Pipeline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline._lazySetupHooks" id="apidoc.element.angoose.Pipeline._lazySetupHooks">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>_lazySetupHooks
        <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lazySetupHooks = function (proto, methodName, errorCb) {
  if (&#x27;undefined&#x27; === typeof proto[methodName].numAsyncPres) {
    this.hook(methodName, proto[methodName], errorCb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.accept" id="apidoc.element.angoose.Pipeline.accept">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>accept
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.execute(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.execute" id="apidoc.element.angoose.Pipeline.execute">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>execute
        <span class="apidocSignatureSpan">(ctx, invocation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (ctx, invocation, callback){
        [&#x27;allowed&#x27;, &#x27;target&#x27;, &#x27;arguments&#x27;,&#x27;result&#x27;,&#x27;redacted&#x27;].forEach(function(key){
            delete invocation[key];
        });

        var dmain = domain.create();
        dmain.context = ctx;
        //var excutionStorage = storageFactory.createNamespace(&#x22;angoose&#x22;);
<span class="apidocCodeCommentSpan">        /** here comes the main body of the processing */
</span>        dmain.run(function(){
                var pipeline = new Pipeline();
                var seqnum = invocation.seqnumber;
                var sent = false;
                logger.debug(&#x22;------ BEGIN RMI #&#x22;, seqnum, invocation.clazz, invocation.method );
                logger.trace(&#x22;Invocation object: &#x22;,invocation);
                //invocation.method = req.params.method;  /** method must be part of the path for routes permission etc */
                ctx.seqnum = seqnum;
                ctx.invocation = invocation;

                function handleError(err, exName){
                    if(sent){
                        logger.debug(&#x22;Response already sent&#x22;)
                        return;
                    }
                    /**@todo: err may cause Circular issue when converting to JSON */
                    var ex = new Exception(err, exName);
                    invocation.exception = ex;

                    pipeline.formatError(invocation, function(er){
                        logger.debug(&#x22;====== END RMI with Error  #&#x22;, seqnum,  ex);
                        callback(invocation.packed);
                        sent  = true;
                    });
                }
                dmain.on(&#x27;error&#x27;,  function uncaught(ex){
                    logger.error(&#x22;Uncaught error in invocation #&#x22;+seqnum, ex);
                    /**@todo: restart server if too many errors */
                    handleError(  &#x22;Unexpected Server Error&#x22;, &#x27;RuntimeError&#x27;);
                });

                /** setting execution context */
                var sent = false;

                var modelName = invocation.clazz;
                var seqnum = invocation.seqnumber;
                //excutionStorage.set(&#x22;context&#x22;, ctx);
                pipeline.authorize(invocation,   function(err){
                    if(err) return handleError(err);
                    if(! invocation.allowed) return handleError(&#x22;Access Denied&#x22;, &#x22;AuthError&#x22;);

                    pipeline.resolveTarget(invocation,   function(err){
                        if(err) return handleError(err);

                        if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);

                        pipeline.resolveArguments(invocation,function(err){
                            if(err) return handleError(err);

                            if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
                            pipeline.invoke(invocation, function(ex){

                                if(ex) return handleError(ex);
                                pipeline.redact(invocation, function(err){
                                    if(err) return handleError(err);
                                    pipeline.pack(invocation, function(err){
                                        if(err) return handleError(err);
                                        //res.send(200, packedData);
                                        callback(invocation.packed);
                                        sent = true;
                                        logger.debug(&#x22;====== END RMI Succeeded #&#x22;, seqnum);
                                        if(Array.isArray(invocation.packed &#x26;&#x26; invocation.packed.retval) &#x26;&#x26; invocation.packed.retval
.length&#x3e;0){
                                            logger.trace(&#x22;Response is an array with length:&#x22;,  invocation.packed.retval.length, &#x22;
First element:&#x22;,invocation.packed.retval[0] ); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        });/** end context closure */
}

Pipeline.accept = function accept(req, res){
    var invocation = decode(req.body);
    var ctx = new  Context({request:req, response:res} )
    Pipeline.<span class="apidocCodeKeywordSpan">execute</span>(ctx, invocation, function(data){
        // traverse(data).forEach(function(){
            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail
        // });
        res.send(200, data);
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.hook" id="apidoc.element.angoose.Pipeline.hook">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>hook
        <span class="apidocSignatureSpan">(name, fn, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hook = function (name, fn, errorCb) {
  if (arguments.length === 1 &#x26;&#x26; typeof name === &#x27;object&#x27;) {
    for (var k in name) { // `name` is a hash of hookName-&#x3e;hookFn
      this.hook(k, name[k]);
    }
    return;
  }

  var proto = this.prototype || this
    , pres = proto._pres = proto._pres || {}
    , posts = proto._posts = proto._posts || {};
  pres[name] = pres[name] || [];
  posts[name] = posts[name] || [];

  proto[name] = function () {
    var self = this
      , hookArgs // arguments eventually passed to the hook - are mutable
      , lastArg = arguments[arguments.length-1]
      , pres = this._pres[name]
      , posts = this._posts[name]
      , _total = pres.length
      , _current = -1
      , _asyncsLeft = proto[name].numAsyncPres
      , _next = function () {
          if (arguments[0] instanceof Error) {
            return handleError(arguments[0]);
          }
          var _args = Array.prototype.slice.call(arguments)
            , currPre
            , preArgs;
          if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
            hookArgs = _args;
          if (++_current &#x3c; _total) {
            currPre = pres[_current]
            if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
              throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
            if (currPre.length &#x3c; 1)
              throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
            preArgs = (currPre.isAsync
                        ? [once(_next), once(_asyncsDone)]
                        : [once(_next)]).concat(hookArgs);
            return currPre.apply(self, preArgs);
          } else if (!proto[name].numAsyncPres) {
            return _done.apply(self, hookArgs);
          }
        }
      , _done = function () {
          var args_ = Array.prototype.slice.call(arguments)
            , ret, total_, current_, next_, done_, postArgs;

          if (_current === _total) {

            next_ = function () {
              if (arguments[0] instanceof Error) {
                return handleError(arguments[0]);
              }
              var args_ = Array.prototype.slice.call(arguments, 1)
                , currPost
                , postArgs;
              if (args_.length) hookArgs = args_;
              if (++current_ &#x3c; total_) {
                currPost = posts[current_]
                if (currPost.length &#x3c; 1)
                  throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
                postArgs = [once(next_)].concat(hookArgs);
                return currPost.apply(self, postArgs);
              } else if (typeof lastArg === &#x27;function&#x27;){
                // All post handlers are done, call original callback function
                return lastArg.apply(self, arguments);
              }
            };

            // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
            // a callback.  We trap that callback and wait to call it until all post handlers have finished.
            if(typeof lastArg === &#x27;function&#x27;){
              args_[args_.length - 1] = once(next_);
            }

            total_ = posts.length;
            current_ = -1;
            ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

            if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
            return ret;
          }
        };
    if (_asyncsLeft) {
      function _asyncsDone (err) {
        if (err &#x26;&#x26; err instanceof Error) {
          return handleError(err);
        }
        --_asyncsLeft || _done.apply(self, hookArgs);
      }
    }
    function handleError (err) {
      if (&#x27;function&#x27; == typeof lastArg)
        return lastArg(err);
      if (errorCb) return errorCb.call(self, err);
      throw err;
    }
    return _next.apply(this, arguments);
  };

  proto[name].numAsyncPres = 0;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
exports.addHookPoints = function(clazz, hookables){
var hooks = require(&#x22;hooks&#x22;);
hookables = hookables || clazz.hookables;
for (var k in hooks) { clazz[k] = hooks[k];}

_.each(hookables, function(hookable){
    clazz.<span class="apidocCodeKeywordSpan">hook</span>(hookable, clazz.prototype[hookable]);
});
clazz.removePost = removePost;
};

exports.removeHookPoints = function(clazz, hookables){
hookables = hookables || clazz.hookables;
_.each(hookables, function(hookable){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.post" id="apidoc.element.angoose.Pipeline.post">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>post
        <span class="apidocSignatureSpan">(name, isAsync, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (name, isAsync, fn) {
  if (arguments.length === 2) {
    fn = isAsync;
    isAsync = false;
  }
  var proto = this.prototype || this
    , posts = proto._posts = proto._posts || {};

  this._lazySetupHooks(proto, name);
  (posts[name] = posts[name] || []).push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// angular http ignores all key names starting with $, this will break the mongo query
data = encode$(data);
 console.log(&#x22;****** BEGIN Client Call #&#x22;, data.seqnumber,modelName, methodName, data);
var http = depends[&#x27;http&#x27;];
var theQ = depends[&#x27;promise&#x27;];
if (!http || !theQ) throw &#x22;Missing http and/or Q dependencies&#x22;;
var deferred = theQ.defer();
var ret = http.<span class="apidocCodeKeywordSpan">post</span>((getConfigs().urlPrefix || &#x27;/angoose&#x27;) + &#x22;/rmi/&#x22
; + modelName + &#x22;/&#x22; + methodName, data);
ret.done(function(retdata) {
     console.log(&#x22;****** END Client Call #&#x22;, data.seqnumber, &#x22; result:&#x22;, retdata);
    var val = undefined;
    //@todo construct object, ret value types:  1) model data, 2) list of model data, 3) String, 4) object
    if (retdata &#x26;&#x26; retdata.retval  &#x26;&#x26; ( retdata.datatype ==&#x27;model&#x27; || retdata.datatype ==&#x27;models
&#x27;)) {

        if(retdata.datatype == &#x27;model&#x27;){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.pre" id="apidoc.element.angoose.Pipeline.pre">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>pre
        <span class="apidocSignatureSpan">(name, isAsync, fn, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pre = function (name, isAsync, fn, errorCb) {
  if (&#x27;boolean&#x27; !== typeof arguments[1]) {
    errorCb = fn;
    fn = isAsync;
    isAsync = false;
  }
  var proto = this.prototype || this
    , pres = proto._pres = proto._pres || {};

  this._lazySetupHooks(proto, name, errorCb);

  if (fn.isAsync = isAsync) {
    proto[name].numAsyncPres++;
  }

  (pres[name] = pres[name] || []).push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getModelSchema(){
    var schema =  new angoose.getMongoose().Schema({
         role: {type:String, label:&#x27;Role&#x27;, required:true, tags:[&#x27;default-list&#x27;], unique:true },
         desc: {type:String, label:&#x27;Description&#x27;,tags:[&#x27;default-list&#x27;]}
    }, {collection: COLLECTION_NAME});

    schema.<span class="apidocCodeKeywordSpan">pre</span>(&#x27;save&#x27;, function(next){
       cached =  null; // invalidate the cache
       next();
    });

    return schema;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.removePost" id="apidoc.element.angoose.Pipeline.removePost">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePost
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removePost(name, fnToRemove) {
    var proto = this.prototype || this
      , posts = proto._posts || (proto._posts || {});
    if (!posts[name]) return this;
    if (arguments.length === 1) {
      // Remove all pre callbacks for hook `name`
      posts[name].length = 0;
    } else {
      posts[name] = posts[name].filter( function (currFn) {
        return currFn !== fnToRemove;
      });
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
clazz.removePost = removePost;
};

exports.removeHookPoints = function(clazz, hookables){
hookables = hookables || clazz.hookables;
_.each(hookables, function(hookable){
    clazz.removePre(hookable).<span class="apidocCodeKeywordSpan">removePost</span>(hookable);
});
};


function removePost(name, fnToRemove) {
var proto = this.prototype || this
  , posts = proto._posts || (proto._posts || {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.removePre" id="apidoc.element.angoose.Pipeline.removePre">
        function <span class="apidocSignatureSpan">angoose.Pipeline.</span>removePre
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePre = function (name, fnToRemove) {
  var proto = this.prototype || this
    , pres = proto._pres || (proto._pres || {});
  if (!pres[name]) return this;
  if (arguments.length === 1) {
    // Remove all pre callbacks for hook `name`
    pres[name].length = 0;
  } else {
    pres[name] = pres[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
clazz.removePost = removePost;
};

exports.removeHookPoints = function(clazz, hookables){
hookables = hookables || clazz.hookables;
_.each(hookables, function(hookable){
    clazz.<span class="apidocCodeKeywordSpan">removePre</span>(hookable).removePost(hookable);
});
};


function removePost(name, fnToRemove) {
var proto = this.prototype || this
  , posts = proto._posts || (proto._posts || {});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Pipeline.prototype" id="apidoc.module.angoose.Pipeline.prototype">module angoose.Pipeline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.authorize" id="apidoc.element.angoose.Pipeline.prototype.authorize">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>authorize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorize = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/** setting execution context */
var sent = false;

var modelName = invocation.clazz;
var seqnum = invocation.seqnumber;
//excutionStorage.set(&#x22;context&#x22;, ctx);
pipeline.<span class="apidocCodeKeywordSpan">authorize</span>(invocation,   function(err){
    if(err) return handleError(err);
    if(! invocation.allowed) return handleError(&#x22;Access Denied&#x22;, &#x22;AuthError&#x22;);

    pipeline.resolveTarget(invocation,   function(err){
        if(err) return handleError(err);

        if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.formatError" id="apidoc.element.angoose.Pipeline.prototype.formatError">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>formatError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatError = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        logger.debug(&#x22;Response already sent&#x22;)
        return;
    }
    /**@todo: err may cause Circular issue when converting to JSON */
    var ex = new Exception(err, exName);
    invocation.exception = ex;

    pipeline.<span class="apidocCodeKeywordSpan">formatError</span>(invocation, function(er){
        logger.debug(&#x22;====== END RMI with Error  #&#x22;, seqnum,  ex);
        callback(invocation.packed);
        sent  = true;
    });
}
dmain.on(&#x27;error&#x27;,  function uncaught(ex){
    logger.error(&#x22;Uncaught error in invocation #&#x22;+seqnum, ex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.invoke" id="apidoc.element.angoose.Pipeline.prototype.invoke">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>invoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);

pipeline.resolveArguments(invocation,function(err){
    if(err) return handleError(err);

    if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
    pipeline.<span class="apidocCodeKeywordSpan">invoke</span>(invocation, function(ex){

        if(ex) return handleError(ex);
        pipeline.redact(invocation, function(err){
            if(err) return handleError(err);
            pipeline.pack(invocation, function(err){
                if(err) return handleError(err);
                //res.send(200, packedData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.pack" id="apidoc.element.angoose.Pipeline.prototype.pack">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>pack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pack = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
pipeline.invoke(invocation, function(ex){

    if(ex) return handleError(ex);
    pipeline.redact(invocation, function(err){
        if(err) return handleError(err);
        pipeline.<span class="apidocCodeKeywordSpan">pack</span>(invocation, function(err){
            if(err) return handleError(err);
            //res.send(200, packedData);
            callback(invocation.packed);
            sent = true;
            logger.debug(&#x22;====== END RMI Succeeded #&#x22;, seqnum);
            if(Array.isArray(invocation.packed &#x26;&#x26; invocation.packed.retval) &#x26;&#x26; invocation.packed.retval.length
&#x3e;0){
                logger.trace(&#x22;Response is an array with length:&#x22;,  invocation.packed.retval.length, &#x22;First element
:&#x22;,invocation.packed.retval[0] );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.redact" id="apidoc.element.angoose.Pipeline.prototype.redact">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>redact
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redact = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        pipeline.resolveArguments(invocation,function(err){
if(err) return handleError(err);

if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
pipeline.invoke(invocation, function(ex){

    if(ex) return handleError(ex);
    pipeline.<span class="apidocCodeKeywordSpan">redact</span>(invocation, function(err){
        if(err) return handleError(err);
        pipeline.pack(invocation, function(err){
            if(err) return handleError(err);
            //res.send(200, packedData);
            callback(invocation.packed);
            sent = true;
            logger.debug(&#x22;====== END RMI Succeeded #&#x22;, seqnum);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.resolveArguments" id="apidoc.element.angoose.Pipeline.prototype.resolveArguments">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveArguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveArguments = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(! invocation.allowed) return handleError(&#x22;Access Denied&#x22;, &#x22;AuthError&#x22;);

pipeline.resolveTarget(invocation,   function(err){
    if(err) return handleError(err);

    if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);

    pipeline.<span class="apidocCodeKeywordSpan">resolveArguments</span>(invocation,function(err){
        if(err) return handleError(err);

        if(!invocation.arguments) return handleError(&#x22;Arguments not resolved.&#x22;);
        pipeline.invoke(invocation, function(ex){

            if(ex) return handleError(ex);
            pipeline.redact(invocation, function(err){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Pipeline.prototype.resolveTarget" id="apidoc.element.angoose.Pipeline.prototype.resolveTarget">
        function <span class="apidocSignatureSpan">angoose.Pipeline.prototype.</span>resolveTarget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveTarget = function () {
  var self = this
    , hookArgs // arguments eventually passed to the hook - are mutable
    , lastArg = arguments[arguments.length-1]
    , pres = this._pres[name]
    , posts = this._posts[name]
    , _total = pres.length
    , _current = -1
    , _asyncsLeft = proto[name].numAsyncPres
    , _next = function () {
        if (arguments[0] instanceof Error) {
          return handleError(arguments[0]);
        }
        var _args = Array.prototype.slice.call(arguments)
          , currPre
          , preArgs;
        if (_args.length &#x26;&#x26; !(arguments[0] == null &#x26;&#x26; typeof lastArg === &#x27;function&#x27;))
          hookArgs = _args;
        if (++_current &#x3c; _total) {
          currPre = pres[_current]
          if (currPre.isAsync &#x26;&#x26; currPre.length &#x3c; 2)
            throw new Error(&#x22;Your pre must have next and done arguments -- e.g., function (next, done, ...)&#x22;);
          if (currPre.length &#x3c; 1)
            throw new Error(&#x22;Your pre must have a next argument -- e.g., function (next, ...)&#x22;);
          preArgs = (currPre.isAsync
                      ? [once(_next), once(_asyncsDone)]
                      : [once(_next)]).concat(hookArgs);
          return currPre.apply(self, preArgs);
        } else if (!proto[name].numAsyncPres) {
          return _done.apply(self, hookArgs);
        }
      }
    , _done = function () {
        var args_ = Array.prototype.slice.call(arguments)
          , ret, total_, current_, next_, done_, postArgs;

        if (_current === _total) {

          next_ = function () {
            if (arguments[0] instanceof Error) {
              return handleError(arguments[0]);
            }
            var args_ = Array.prototype.slice.call(arguments, 1)
              , currPost
              , postArgs;
            if (args_.length) hookArgs = args_;
            if (++current_ &#x3c; total_) {
              currPost = posts[current_]
              if (currPost.length &#x3c; 1)
                throw new Error(&#x22;Your post must have a next argument -- e.g., function (next, ...)&#x22;);
              postArgs = [once(next_)].concat(hookArgs);
              return currPost.apply(self, postArgs);
            } else if (typeof lastArg === &#x27;function&#x27;){
              // All post handlers are done, call original callback function
              return lastArg.apply(self, arguments);
            }
          };

          // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
          // a callback.  We trap that callback and wait to call it until all post handlers have finished.
          if(typeof lastArg === &#x27;function&#x27;){
            args_[args_.length - 1] = once(next_);
          }

          total_ = posts.length;
          current_ = -1;
          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

          if (total_ &#x26;&#x26; typeof lastArg !== &#x27;function&#x27;) return next_();  // no callback provided, execute next_() manually
          return ret;
        }
      };
  if (_asyncsLeft) {
    function _asyncsDone (err) {
      if (err &#x26;&#x26; err instanceof Error) {
        return handleError(err);
      }
      --_asyncsLeft || _done.apply(self, hookArgs);
    }
  }
  function handleError (err) {
    if (&#x27;function&#x27; == typeof lastArg)
      return lastArg(err);
    if (errorCb) return errorCb.call(self, err);
    throw err;
  }
  return _next.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelName = invocation.clazz;
var seqnum = invocation.seqnumber;
//excutionStorage.set(&#x22;context&#x22;, ctx);
pipeline.authorize(invocation,   function(err){
    if(err) return handleError(err);
    if(! invocation.allowed) return handleError(&#x22;Access Denied&#x22;, &#x22;AuthError&#x22;);

    pipeline.<span class="apidocCodeKeywordSpan">resolveTarget</span>(invocation,   function(err){
        if(err) return handleError(err);

        if(!invocation.target) return handleError(&#x22;Target not resolved.&#x22;, &#x22;ModuleNotFoundError&#x22;);

        pipeline.resolveArguments(invocation,function(err){
            if(err) return handleError(err);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Remotable" id="apidoc.module.angoose.Remotable">module angoose.Remotable</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Remotable.Remotable" id="apidoc.element.angoose.Remotable.Remotable">
        function <span class="apidocSignatureSpan">angoose.</span>Remotable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Remotable = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.constructor" id="apidoc.element.angoose.Remotable.constructor">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.extend" id="apidoc.element.angoose.Remotable.extend">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace(&#x22;Extending from &#x22;,   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == &#x27;function&#x27;){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require(&#x22;./angoose&#x22;).registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
    var myQ = angular.<span class="apidocCodeKeywordSpan">extend</span>({}, $q)
    myQ.defer = function(){
        var out = $q.defer.apply($q, arguments);
        if(out.promise.done) return out;
        out.promise.done = function(successCallback, errorCallback){
            out.promise.then(successCallback, errorCallback);
        }
        return out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.getContext" id="apidoc.element.angoose.Remotable.getContext">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.isRemotableReserved" id="apidoc.element.angoose.Remotable.isRemotableReserved">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>isRemotableReserved
        <span class="apidocSignatureSpan">(methodName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRemotableReserved(methodName){
<span class="apidocCodeCommentSpan">    /** check if method is reserved by the Remotable interface */
</span>  return methodName.indexOf(&#x22;_&#x22;) == 0 || methodName.indexOf(&#x22;$&#x22;) == 0 || [&#x27;constructor&#x27;,   &#x27;isRemotableReserved&#x27;].indexOf(methodName
)&#x3e;=0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#x3e; (
val) != &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22;&#x3e
;continue&#x3c;/span&#x3e;;
schema.statics[name] = val;
    }
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; schema;
}

&#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#
x22;title&#x22;&#x3e;filter&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(methodName)&#x3c;/span&#x3e;{&#x3c;/span&#
x3e;
     &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(Remotable.<span class="apidocCodeKeywordSpan">isRemotableReserved
</span>(methodName)) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; &#x3c;span class=&#x22;literal&#x22;&#x3e
;true&#x3c;/span&#x3e;;
     &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;([&#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;extend&#x27;&#
x3c;/span&#x3e;, &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;getContext&#x27;&#x3c;/span&#x3e;, &#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;getSchema&#x27;&#x3c;/span&#x3e;,&#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;toJSON&#x27;&#x3c;/span&#x3e; ].
indexOf(methodName)&#x26;gt;=&#x3c;span class=&#x22;number&#x22;&#x3e;0&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22;&#
x3e;return&#x3c;/span&#x3e; &#x3c;span class=&#x22;literal&#x22;&#x3e;true&#x3c;/span&#x3e;;
     &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; &#x3c;span class=&#x22;literal&#x22;&#x3e;false&#x3c;/span
&#x3e;;
}
module.exports = Service;&#x3c;/pre&#x3e;&#x3c;/div&#x3e;&#x3c;/div&#x3e;

&#x3c;/li&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Remotable.mixin" id="apidoc.element.angoose.Remotable.mixin">
        function <span class="apidocSignatureSpan">angoose.Remotable.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || &#x27;Service&#x27;;
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == &#x27;Model&#x27;)
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opts.baseClass = &#x27;Model&#x27;;
    else if(claz instanceof getMongoose().Schema){
        opts.baseClass = &#x27;Model&#x27;;
        claz = getMongoose().model(className, claz);
    }
    else
        opts.baseClass = &#x27;Service&#x27;;
    angoose.Remotable.<span class="apidocCodeKeywordSpan">mixin</span>(opts, claz);
}
_.extend(claz._angoosemeta, nameOrOpts);

beans[className] = claz;
//if(!nameOrOpts.isExtension)
    logger.debug(&#x22;Registered module&#x22;, claz._angoosemeta.baseClass, className);
return claz;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Remotable.prototype" id="apidoc.module.angoose.Remotable.prototype">module angoose.Remotable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Remotable.prototype.getContext" id="apidoc.element.angoose.Remotable.prototype.getContext">
        function <span class="apidocSignatureSpan">angoose.Remotable.prototype.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleService" id="apidoc.module.angoose.SampleService">module angoose.SampleService</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleService.SampleService" id="apidoc.element.angoose.SampleService.SampleService">
        function <span class="apidocSignatureSpan">angoose.</span>SampleService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SampleService = function (){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.config" id="apidoc.element.angoose.SampleService.config">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require(&#x22;./test/server&#x22;).startServer();
    });

    grunt.registerTask(&#x27;autotest&#x27;, &#x27;watch and test&#x27;, function(argPattern) {

        var watched= [&#x22;lib/**/*.js&#x22;, &#x22;test/**/*.js&#x22;, &#x22;models/**/*.js&#x22;, &#x22;extensions/**/*.js&#x22
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>(&#x27;watch.autotest.files&#x27;, watched);
        grunt.config(&#x27;watch.autotest.tasks&#x27;,  (argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;));
        grunt.task.run(argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;);
        grunt.task.run(&#x27;watch:autotest&#x27;);

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.getContext" id="apidoc.element.angoose.SampleService.getContext">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.getSchema" id="apidoc.element.angoose.SampleService.getSchema">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != &#x27;function&#x27;) continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == &#x27;function&#x27;){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.listFavoriteDestinations" id="apidoc.element.angoose.SampleService.listFavoriteDestinations">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>listFavoriteDestinations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listFavoriteDestinations = function (){
    return [&#x22;Paris&#x22;, &#x22;Virgin Islands&#x22;, &#x22;Antarctic&#x22;]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        console.log(&#x22;Done done&#x22;, arguments);
        assert.equal(exists, false);
        done();
    });
});
  it(&#x22;Sample Service&#x22;, function(done){
    var SampleService = AngooseClient.getClass(&#x22;SampleService&#x22;);
    SampleService.<span class="apidocCodeKeywordSpan">listFavoriteDestinations</span>().done(function(places){
        console.log(&#x22;Places&#x22;, places);
        assert(places &#x26;&#x26; places[0], &#x22;Paris&#x22;);
        done();
    });
});

it(&#x22;Test Promise&#x22;, function(done){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testErrorBack" id="apidoc.element.angoose.SampleService.testErrorBack">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testErrorBack
        <span class="apidocSignatureSpan">($callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testErrorBack = function ($callback){
    console.log(&#x22;In testErrorCallback&#x22;);
    $callback(&#x22;Error in testError&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            assert.equal(flag.hook ,&#x27;post&#x27;);
            done();
        });
    });

    it(&#x22;Post Hook with error&#x22;, function(done){
        var SS =  angoose.client().module(&#x27;SampleService&#x27;);
        SS.<span class="apidocCodeKeywordSpan">testErrorBack</span>(function(err, u){
            console.log(&#x22;post hook&#x22;, err, u)
            assert(err)
            done();
        });
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testExecutionContext" id="apidoc.element.angoose.SampleService.testExecutionContext">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testExecutionContext
        <span class="apidocSignatureSpan">($callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remote($callback){
        var self = this;
        var su = require(&#x22;./SampleUser&#x22;);
        su.findOne(angoose.bind(   function(err, res){
                var ctx = self.getContext();
                console.log(&#x22;In testExecutionContext &#x22;+ ctx.seqnum)
                var req = ctx.getRequest();
                $callback(false, req.params[&#x27;method&#x27;]);
        }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
});

it(&#x22;Execution Context&#x22;, function(done){
    console.log(&#x22;Execution context test&#x22;);

    var SampleService = angoose.client().module(&#x22;SampleService&#x22;);
    SampleService.<span class="apidocCodeKeywordSpan">testExecutionContext</span>().done(function(data){
        console.log(&#x22;Got context path&#x22;, data)
        assert.equal( data, &#x27;testExecutionContext&#x27;);
        done();
    }, function(err){

    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleService.testPromiseReturn" id="apidoc.element.angoose.SampleService.testPromiseReturn">
        function <span class="apidocSignatureSpan">angoose.SampleService.</span>testPromiseReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testPromiseReturn = function (){
    console.log(&#x22;testPromiseReturn!&#x22;);
    var out = Q.defer();
    out.resolve(&#x22;PromiseOK&#x22;);
    process.nextTick(function(){
        out.resolve(&#x22;PromiseOK&#x22;);
    })
    return out.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            assert(places &#x26;&#x26; places[0], &#x22;Paris&#x22;);
            done();
        });
    });

    it(&#x22;Test Promise&#x22;, function(done){
        var SampleService = AngooseClient.getClass(&#x22;SampleService&#x22;);
        SampleService.<span class="apidocCodeKeywordSpan">testPromiseReturn</span>().done(function(res){
            assert.equal(res, &#x22;PromiseOK&#x22;);
            done();
        })
    })

});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUser" id="apidoc.module.angoose.SampleUser">module angoose.SampleUser</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUser.SampleUser" id="apidoc.element.angoose.SampleUser.SampleUser">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUser
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.checkExists" id="apidoc.element.angoose.SampleUser.checkExists">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>checkExists
        <span class="apidocSignatureSpan">(email)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExists = function (email){
    //_static_remote
    console.log(&#x22;in checkExists&#x22;,email);
    require(&#x22;fs&#x22;);  // do a server side operation to ensure this can only be done in the server side.
    if(email &#x26;&#x26; email.indexOf(&#x27;new&#x27;)&#x3e;=0) return false;
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        assert.equal(suser.password, &#x22;abcsalt123&#x22;);
        assert.equal(res, &#x22;Password changed&#x22;);
        done();
    });
});
  it(&#x22;Static method&#x22;, function(done){
    var SampleUser = AngooseClient.getClass(&#x22;SampleUser&#x22;);
    SampleUser.<span class="apidocCodeKeywordSpan">checkExists</span>(&#x27;newmeil@he.com&#x27;).done(function(exists){
        console.log(&#x22;Done done&#x22;, arguments);
        assert.equal(exists, false);
        done();
    });
});
  it(&#x22;Sample Service&#x22;, function(done){
    var SampleService = AngooseClient.getClass(&#x22;SampleService&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.getSample" id="apidoc.element.angoose.SampleUser.getSample">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>getSample
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSample = function (){
    // this should refer to the model class
    console.log(&#x22;get sample user&#x22;);
    var instance = new this( sampleUserData);
    return instance;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.model" id="apidoc.element.angoose.SampleUser.model">
        function <span class="apidocSignatureSpan">angoose.SampleUser.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            promise: myQ
        });
        return AngooseClient;
})
function factoryFunc(modelName){
    console.log(&#x22;Create factory for model &#x22;+ modelName)
    angularModule.factory(modelName , function($http, $q, $rootScope, $timeout, angoose){
        var acModel = AngooseClient.<span class="apidocCodeKeywordSpan">model</span>(modelName);
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUser.prototype" id="apidoc.module.angoose.SampleUser.prototype">module angoose.SampleUser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUser.prototype.getFullname" id="apidoc.element.angoose.SampleUser.prototype.getFullname">
        function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>getFullname
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function portable(){
    //_instance_portable
    console.log(&#x22;getFullname&#x22;, this);
    return  (this.firstname ? this.firstname +&#x22; &#x22;: &#x22;&#x22;) + (this.lastname || &#x22;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                eval(body);
             }
             catch(er){
                 console.error(&#x22;ERRORERRORERRORERRORERRORERRORERRORERRORv&#x22;, body, er)
             }
            var SampleUser = AngooseClient.getClass(&#x22;SampleUser&#x22;);
            var suser = new SampleUser( util.testuser);
            assert.equal(suser.<span class="apidocCodeKeywordSpan">getFullname</span>(),&#x22;Gaelyn Hurd&#x22;);
            done();
       });
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUser.prototype.setPassword" id="apidoc.element.angoose.SampleUser.prototype.setPassword">
        function <span class="apidocSignatureSpan">angoose.SampleUser.prototype.</span>setPassword
        <span class="apidocSignatureSpan">(newPassword, $context, $callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPassword = function (newPassword, $context, $callback){
    // instance method, reset user&#x27;s password.
    if(!$callback ) throw &#x22;$callback not injected&#x22;;
    if(!$context) throw &#x22;$context not injected&#x22;;
    //var cryptor = require(&#x22;crypto&#x22;); // require node module crypto
    //this.password = cryptor.encrypt(&#x22;salt&#x22;, newPassword);
    this.password  = newPassword +&#x22;salt123&#x22;; // fake code
    $callback(false, &#x22;Password changed&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

describe(&#x22;Core Tests&#x22;, function(){
 var angoose = util.initAngoose();
 var AngooseClient = util.angooseClient();
it(&#x22;Dependency injection&#x22;, function(done){
    var SampleUser = AngooseClient.getClass(&#x22;SampleUser&#x22;);
    var suser = new SampleUser( userdata);
    suser.<span class="apidocCodeKeywordSpan">setPassword</span>(&#x27;abc&#x27;).done(function(res){
        console.log(&#x22;setpassword done&#x22;, arguments);
        assert.equal(suser.password, &#x22;abcsalt123&#x22;);
        assert.equal(res, &#x22;Password changed&#x22;);
        done();
    });
});
  it(&#x22;Static method&#x22;, function(done){
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.SampleUserGroup" id="apidoc.module.angoose.SampleUserGroup">module angoose.SampleUserGroup</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup.SampleUserGroup" id="apidoc.element.angoose.SampleUserGroup.SampleUserGroup">
        function <span class="apidocSignatureSpan">angoose.</span>SampleUserGroup
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.SampleUserGroup.model" id="apidoc.element.angoose.SampleUserGroup.model">
        function <span class="apidocSignatureSpan">angoose.SampleUserGroup.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            promise: myQ
        });
        return AngooseClient;
})
function factoryFunc(modelName){
    console.log(&#x22;Create factory for model &#x22;+ modelName)
    angularModule.factory(modelName , function($http, $q, $rootScope, $timeout, angoose){
        var acModel = AngooseClient.<span class="apidocCodeKeywordSpan">model</span>(modelName);
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Service" id="apidoc.module.angoose.Service">module angoose.Service</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Service.Service" id="apidoc.element.angoose.Service.Service">
        function <span class="apidocSignatureSpan">angoose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Service = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.constructor" id="apidoc.element.angoose.Service.constructor">
        function <span class="apidocSignatureSpan">angoose.Service.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
  if (disable_constructor)
    return;
  var proper_this = context === this ? cheapNew(arguments.callee) : this;
  if (proper_this.__init__)
    proper_this.__init__.apply(proper_this, arguments);
  proper_this.$class = rv;
  return proper_this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.extend" id="apidoc.element.angoose.Service.extend">
        function <span class="apidocSignatureSpan">angoose.Service.</span>extend
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, options){
    options = options||{};
    var parentClass = this;
    logger.trace(&#x22;Extending from &#x22;,   parentClass._angoosemeta.name, options);
    var rv = null;
    if(typeof (target) == &#x27;function&#x27;){
        rv = target;
        mixinInstance(parentClass, rv, options);

<span class="apidocCodeCommentSpan">        /**@todo: temp hack */
</span>        bindMongooseMethods(rv);
    }
    else{
        /** schema object */
        rv = parentClass.$extend( target );
    }

    /** mixin Angoose class level functions */
    rv = mixinStatic(parentClass, rv, options);
    if(rv._angoosemeta.name){
        /**  register it with Angoose */
       //require(&#x22;./angoose&#x22;).registerClass(rv._angoosemeta.name, rv);
    }
    return rv;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
    var myQ = angular.<span class="apidocCodeKeywordSpan">extend</span>({}, $q)
    myQ.defer = function(){
        var out = $q.defer.apply($q, arguments);
        if(out.promise.done) return out;
        out.promise.done = function(successCallback, errorCallback){
            out.promise.then(successCallback, errorCallback);
        }
        return out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.getContext" id="apidoc.element.angoose.Service.getContext">
        function <span class="apidocSignatureSpan">angoose.Service.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.getSchema" id="apidoc.element.angoose.Service.getSchema">
        function <span class="apidocSignatureSpan">angoose.Service.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSchema = function (){
    var thisClass = this;
    var schema = {statics: {} };

    schema.methods = _.extend({}, thisClass.prototype)

    for(var name in thisClass.prototype){
        if( filter(name) ) continue;
        if(!thisClass.prototype.hasOwnProperty(name)) continue;
        var val = thisClass.prototype[name];
        if(typeof(val)!=&#x27;function&#x27;) continue;
        schema.methods[name] = val;
    }

    for(var name in thisClass){
        if(!thisClass.hasOwnProperty(name)) continue;
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != &#x27;function&#x27;) continue;
        schema.statics[name] = val;
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Service.mixin" id="apidoc.element.angoose.Service.mixin">
        function <span class="apidocSignatureSpan">angoose.Service.</span>mixin
        <span class="apidocSignatureSpan">(opts, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (opts, target){
    opts = opts || {};
    target.getSchema = getSchema;
    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);
    target._angoosemeta.baseClass = target._angoosemeta.baseClass || &#x27;Service&#x27;;
    target.getContext = getContext; //deprecated
    target.config = config;
    if(target._angoosemeta.baseClass == &#x27;Model&#x27;)
        bindMongooseMethods(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        opts.baseClass = &#x27;Model&#x27;;
    else if(claz instanceof getMongoose().Schema){
        opts.baseClass = &#x27;Model&#x27;;
        claz = getMongoose().model(className, claz);
    }
    else
        opts.baseClass = &#x27;Service&#x27;;
    angoose.Remotable.<span class="apidocCodeKeywordSpan">mixin</span>(opts, claz);
}
_.extend(claz._angoosemeta, nameOrOpts);

beans[className] = claz;
//if(!nameOrOpts.isExtension)
    logger.debug(&#x22;Registered module&#x22;, claz._angoosemeta.baseClass, className);
return claz;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Service.prototype" id="apidoc.module.angoose.Service.prototype">module angoose.Service.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Service.prototype.toJSON" id="apidoc.element.angoose.Service.prototype.toJSON">
        function <span class="apidocSignatureSpan">angoose.Service.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
    return {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; valueType = getValueType(result);  &#x3c;span class=&#x22;comment
&#x22;&#x3e;/** model, models, object, string*/&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; retdata = { success:&#x3c;span class=&#x22;literal&#x22;&#x3e
;true&#x3c;/span&#x3e;,
                    exception:&#x3c;span class=&#x22;literal&#x22;&#x3e;null&#x3c;/span&#x3e;,
                    retval:result,
                    datatype: valueType,
                    seqnumber:seqnum
    };
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;( !invocation.static &#x26;amp;&#x26;amp; (! _.isEqual(target.<
span class="apidocCodeKeywordSpan">toJSON</span>(), invocation.target)))
    {
        &#x3c;span class=&#x22;comment&#x22;&#x3e;/** return the instance data if it has changed */&#x3c;/span&#x3e;
        retdata.instance = target.toJSON();
    }
    sendResponse(&#x3c;span class=&#x22;literal&#x22;&#x3e;false&#x3c;/span&#x3e;, retdata);
    logger.debug(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;====== END RMI Success Result #&#x22;&#x3c;/span&#x3e;, seqnum, &#
x3c;span class=&#x22;string&#x22;&#x3e;&#x22; DONE: &#x22;&#x3c;/span&#x3e;, retdata);
}, &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class
=&#x22;params&#x22;&#x3e;(err)&#x3c;/span&#x3e;{&#x3c;/span&#x3e;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.Todo" id="apidoc.module.angoose.Todo">module angoose.Todo</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.Todo.Todo" id="apidoc.element.angoose.Todo.Todo">
        function <span class="apidocSignatureSpan">angoose.</span>Todo
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.Todo.model" id="apidoc.element.angoose.Todo.model">
        function <span class="apidocSignatureSpan">angoose.Todo.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            promise: myQ
        });
        return AngooseClient;
})
function factoryFunc(modelName){
    console.log(&#x22;Create factory for model &#x22;+ modelName)
    angularModule.factory(modelName , function($http, $q, $rootScope, $timeout, angoose){
        var acModel = AngooseClient.<span class="apidocCodeKeywordSpan">model</span>(modelName);
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.angoose_authorization" id="apidoc.module.angoose.angoose_authorization">module angoose.angoose_authorization</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.beforeCreateBundle" id="apidoc.element.angoose.angoose_authorization.beforeCreateBundle">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>beforeCreateBundle
        <span class="apidocSignatureSpan">( client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function beforeCreateBundle( client){
    // generating PermissionModel schema used on UI
    logger().debug(&#x22;in beforeCreateBundle&#x22;);
    MODEL_NAME = angoose.config(&#x27;angoose-authorization.model-name&#x27;) || MODEL_NAME;
    COLLECTION_NAME = angoose.config(&#x27;angoose-authorization.collection-name&#x27;) || COLLECTION_NAME;

    var schemas = client.schemas;
    var authSchema = getModelSchema();
    // get list of all published methods
    Object.keys(schemas).forEach(function(moduleName){
        var schema = schemas[moduleName];
        if(!schema || moduleName == &#x27;SampleUser&#x27;) return;
        var methodNames =   Object.keys(schema.methods).concat(Object.keys(schema.statics));
        var mod = angoose.module(moduleName);
        if(mod.config &#x26;&#x26; mod.config(&#x22;visibility&#x22;) === false ) return;
        var category = getCategory(mod);
        for(var i=0;methodNames &#x26;&#x26; i&#x3c;methodNames.length;i++){
           var mName = methodNames[i];
           if(mName == &#x27;config&#x27; || mName == &#x27;getSchema&#x27;) continue;
           var fn = schema.methods &#x26;&#x26; schema.methods[mName];
           fn = fn || (schema.statics &#x26;&#x26; schema.statics[mName]);
           if(toolbox.methodType(fn) != &#x27;remote&#x27;) continue;

           var group = getGroup(mod, mName);
           if(!group){
               var path = category +&#x22;.&#x22; + mName;
               var field = {};
               field[path] = {type:Boolean, label: getLabel(mod,mName)};
               authSchema.add(field);
           }
           else if(!authSchema.path(group)){
               // add schema path for the permission group
               var path = category +&#x22;.&#x22; +  toolbox.camelcase(group);
               var field = {};
               field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
               authSchema.add(field);
           }
        };
    });
    var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&#x3e;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
    var permModule = angoose.module(MODEL_NAME, mongooseModel);
    new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods(MODEL_NAME, permModule);
    logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

    setupInitialRoles();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.config" id="apidoc.element.angoose.angoose_authorization.config">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require(&#x22;./test/server&#x22;).startServer();
    });

    grunt.registerTask(&#x27;autotest&#x27;, &#x27;watch and test&#x27;, function(argPattern) {

        var watched= [&#x22;lib/**/*.js&#x22;, &#x22;test/**/*.js&#x22;, &#x22;models/**/*.js&#x22;, &#x22;extensions/**/*.js&#x22
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>(&#x27;watch.autotest.files&#x27;, watched);
        grunt.config(&#x27;watch.autotest.tasks&#x27;,  (argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;));
        grunt.task.run(argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;);
        grunt.task.run(&#x27;watch:autotest&#x27;);

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.getContext" id="apidoc.element.angoose.angoose_authorization.getContext">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.getSchema" id="apidoc.element.angoose.angoose_authorization.getSchema">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != &#x27;function&#x27;) continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == &#x27;function&#x27;){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.postAuthorize" id="apidoc.element.angoose.angoose_authorization.postAuthorize">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postAuthorize
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postAuth(next, invocation){
   var extensionOptions = angoose.config()[EXTENSION]  ;

   var ctx = angoose.getContext();
   var user = ctx.getPrincipal();

   invocation.allowed = true;

<span class="apidocCodeCommentSpan">   /** admin user bypass */
</span>   var superuser =  extensionOptions &#x26;&#x26; extensionOptions.superuser
   if(user.getUserId() ===  superuser ) return next(); // always allow super user admin
   var superrole = ( extensionOptions &#x26;&#x26; extensionOptions.superrole ) || &#x27;admin&#x27;;
   if(user &#x26;&#x26; user.getRoles().indexOf(superrole) &#x3e;=0) return next();

   logger().trace(&#x22;in auth.postAuth:&#x22;, invocation.clazz, invocation.method);
   if(invocation.method == &#x27;signin&#x27; || invocation.method==&#x22;signout&#x22;) return next();

   var mod = angoose.module( invocation.clazz );
   var category = mod.config(EXTENSION +&#x22;.category&#x22;) || invocation.clazz;
   var group = toolbox.camelcase(getGroup(mod, invocation.method)) || invocation.method;

    var roles = user.getRoles() ? user.getRoles(): [];
    roles = Array.isArray(roles)? roles: [ roles ];
    if(roles.indexOf(&#x27;guest&#x27;) &#x3c;0) roles.push(&#x27;guest&#x27;);
    if(roles.indexOf(&#x27;authenticated&#x27;) &#x3c;0) roles.push(&#x27;authenticated&#x27;);

   var allowed = isAllowed( category +&#x22;.&#x22;+ group, roles, function(allowed){
        logger().trace(&#x22;isAllowed: &#x22;, category, group, allowed);
        invocation.allowed = allowed;
        next();
   });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.postInvoke" id="apidoc.element.angoose.angoose_authorization.postInvoke">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>postInvoke
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postInvoke(next, invocation){
    // this is bizzare, if main method fails, this will be called with arguments meant for pre()
    //var invocation = angoose.getContext().getInvocation();
    if( [&#x27;signin&#x27;, &#x27;signout&#x27;].indexOf(invocation.method ) &#x3c;0 ) return next();;

    if(invocation.method == &#x27;signout&#x27;){
        if(angoose.getContext().getRequest().session)
            angoose.getContext().getRequest().session.$authenticatedUser =   null;
        logger().debug(&#x22;User logged out&#x22;);
    }
    var data = invocation.result;
    logger().debug(&#x22;Intercepting login methods&#x22;, invocation.method, data);
    if(!data || !data.userId  )
        return next();;
    if(invocation.method == &#x27;signin&#x27;){
        angoose.getContext().getRequest().session.$authenticatedUser =   {userId: data.userId, roles: data.roles } ;
        logger().debug(&#x22;User authenticated&#x22;, angoose.getContext().getRequest().session.$authenticatedUser );
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.preAuthorize" id="apidoc.element.angoose.angoose_authorization.preAuthorize">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preAuthorize
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preAuth(next){
    logger().trace(&#x22;in preAuth&#x22;, session().$authenticatedUser);
    var authUser = session().$authenticatedUser;
    if(authUser){
        logger().trace(&#x22;Found user in session&#x22;,    authUser);
        //angoose.getContext().setUser( session().$authenticatedUser );
        angoose.getContext().setPrincipal( new angoose.Principal( authUser.userId, authUser.roles) );
    }
    else{
        angoose.getContext().setPrincipal( new angoose.Principal( &#x27;guest&#x27;, &#x27;guest&#x27; ));
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_authorization.preRedact" id="apidoc.element.angoose.angoose_authorization.preRedact">
        function <span class="apidocSignatureSpan">angoose.angoose_authorization.</span>preRedact
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function redact(next){
    logger().trace(&#x22;in auth.preRedact&#x22;);
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.angoose_mongoose" id="apidoc.module.angoose.angoose_mongoose">module angoose.angoose_mongoose</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.afterFormatError" id="apidoc.element.angoose.angoose_mongoose.afterFormatError">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>afterFormatError
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatError(next, invocation){
    var ex = invocation.packed.exception;
    console.log(&#x22;Intercepting error&#x22;, ex);
    // check if it&#x27;s mongoose&#x27;s model error
    var errors = toolbox.getter(ex , &#x27;cause.errors&#x27;);
    if( errors){
        // format model error
        var msg = &#x27;&#x27;;
        Object.keys(errors).forEach(function(key){
            var errobj = errors[key];
            var m = errobj.message+&#x22;&#x22;;
            msg = msg+m+&#x22; &#x22;
        });
        ex.message = msg;
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.config" id="apidoc.element.angoose.angoose_mongoose.config">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require(&#x22;./test/server&#x22;).startServer();
    });

    grunt.registerTask(&#x27;autotest&#x27;, &#x27;watch and test&#x27;, function(argPattern) {

        var watched= [&#x22;lib/**/*.js&#x22;, &#x22;test/**/*.js&#x22;, &#x22;models/**/*.js&#x22;, &#x22;extensions/**/*.js&#x22
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>(&#x27;watch.autotest.files&#x27;, watched);
        grunt.config(&#x27;watch.autotest.tasks&#x27;,  (argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;));
        grunt.task.run(argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;);
        grunt.task.run(&#x27;watch:autotest&#x27;);

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.getContext" id="apidoc.element.angoose.angoose_mongoose.getContext">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.getSchema" id="apidoc.element.angoose.angoose_mongoose.getSchema">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != &#x27;function&#x27;) continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == &#x27;function&#x27;){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postExportModule" id="apidoc.element.angoose.angoose_mongoose.postExportModule">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postExportModule
        <span class="apidocSignatureSpan">( client, moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decorateMongooseSchema( client, moduleName){
    var model = angoose.module(moduleName);
    if(!model.schema || !model.schema.paths) return;
    logger().trace(&#x22;Decorating mongoose model&#x22;, moduleName);

    var schema = client.schemas[moduleName];
    // automatically publish these instance methods
    var instanceMethods = &#x22;save,remove,populate&#x22;;
    instanceMethods.split(&#x22;,&#x22;).forEach(function(m){
        m = m.replace(/\s+/g, &#x27;&#x27;);
        if(!schema.methods[m])
            schema.methods[m]= function remote(){};
    });

    // automatically publish these static methods
    var staticMethods = &#x22;populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update
,remove,count,geoNear,geoSearch,create&#x22;;
    staticMethods.split(&#x22;,&#x22;).forEach(function(m){
        m = m.replace(/\s+/g, &#x27;&#x27;);
        if(!schema.statics[m])
            schema.statics[m]= function remote(){};
    });

    schema.paths = traverse(model.schema.paths).map(function(item){
        if(!item) return;
        if(item.options &#x26;&#x26; typeof(item.options.type) === &#x27;function&#x27; ){
            var fn = item.options.type;
            item.options.type = fn.name || fn.toString();
        }
        else if(typeof(item) == &#x27;function&#x27;)
            this.update( &#x27;not-supported&#x27; );
        if(item.requiredValidator) delete item.requiredValidator;
        if(item.enumValidator) delete item.enumValidator;
        if(item.validators) delete item.validators;<span class="apidocCodeCommentSpan"> /**@todo validators are not supported yet*/
</span>    });
    schema.options = traverse( model.schema.options).clone();
//    filtPaths(schema);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postInvoke" id="apidoc.element.angoose.angoose_mongoose.postInvoke">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postInvoke
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postInvoke(next, invocation){
    var result = invocation.result;

    if(result &#x26;&#x26; result.exec &#x26;&#x26; (result instanceof angoose.getMongoose().Query) ){ // mongoose promise
        logger().debug(&#x22;Return is mongoose query, call exec(). Conditions: &#x22;, result._conditions );
        result.exec( function(err, ret){
            if(err) return next(err);
            invocation.result = ret;
            next();
        });
        return;
    }

    function checkForModelError(result ){
        var target = invocation.static ? null : invocation.target;
        var err = ( target &#x26;&#x26; target.errors) || (result &#x26;&#x26; result.errors);
        if(err)
        {
            // temp error handling
            var msg = &#x27;&#x27;;
            Object.keys(err).forEach(function (errItem) {
                msg += ex.message?&#x22;; &#x22;:&#x22;&#x22;;
                msg += err[errItem].message;
            })
            msg = msg || err.toString();
            return msg;
        }
    }

    process.nextTick(function waitForModelError(){
<span class="apidocCodeCommentSpan">        /** the model error is emitted in next tick */
</span>        var ex = checkForModelError(result);
        if(ex){
            logger().debug(&#x22;Detected model error&#x22;, ex);
            return next(ex);
        }
        next();
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postPack" id="apidoc.element.angoose.angoose_mongoose.postPack">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postPack
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postPack(next, invocation){
    //console.log(&#x22;In mongoose post pack&#x22;, invocation)
    if(!invocation.redacted) return next();
    var type = getValueType(invocation.redacted);
    if(type) invocation.packed.datatype = type;
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.angoose_mongoose.postResolveTarget" id="apidoc.element.angoose.angoose_mongoose.postResolveTarget">
        function <span class="apidocSignatureSpan">angoose.angoose_mongoose.</span>postResolveTarget
        <span class="apidocSignatureSpan">(next, invocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function postResolveTarget(next, invocation){
    if(!invocation.target || invocation.static || ! invocation.instance || !invocation.instance._id ) return next();
    logger().debug(&#x22;postResolveTarget for mongoose models&#x22;);

    var _id = invocation.instance._id;
    logger().trace(&#x22;Loading pristine instance as base&#x22;,invocation.clazz, _id);
    var modelClass = angoose.module(invocation.clazz);
    modelClass.findById(_id,   function mongoCallback(err, pristineInstance){
       if(err || !pristineInstance){
           logger().error(&#x22;Failed to load model by id&#x22;, _id);
           return next(err);
       }
       var pristineObject = pristineInstance.toObject();
       var schema = modelClass.schema;
       Object.keys(schema.paths).forEach(function(path){
           if (/^_/.test(path)) return;
           //var pathSchema = schema.paths[path];
           //var ref = schemaUtil.getReference(pathSchema);
           if (/^_/.test(path)) return;
           var newVal = toolbox.getter(invocation.instance, path);
           var oldVal  =  toolbox.getter(pristineObject, path);
           if(!_.isEqual(oldVal, newVal) &#x26;&#x26;  newVal !==  undefined ){<span class="apidocCodeCommentSpan"> /**@todo: empty value from client side doesn&#x27;t mean set to
 empty, need to implement the $dirty, modified&#x27; */
</span>                if(newVal == &#x27;$CLEAR$&#x27;) newVal = null;
                pristineInstance.set(path,newVal);
                logger().trace(&#x22;seting&#x22;, path, &#x22;: &#x22;,oldVal, &#x22; --&#x3e; &#x22;, newVal, &#x22; NOW dirty? &#x22;,  pristineInstance.isModified(path));
           }
       });
       invocation.target = pristineInstance;
       next();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.classy" id="apidoc.module.angoose.classy">module angoose.classy</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.classy.classy" id="apidoc.element.angoose.classy.classy">
        function <span class="apidocSignatureSpan">angoose.</span>classy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classy = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.login_service" id="apidoc.module.angoose.login_service">module angoose.login_service</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.login_service.config" id="apidoc.element.angoose.login_service.config">
        function <span class="apidocSignatureSpan">angoose.login_service.</span>config
        <span class="apidocSignatureSpan">(path, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(path, opts){
    var conf = this._angoosemeta;
    switch(arguments.length){
        case 0: return conf;
        case 1: return toolbox.getter(conf, path);
        case 2: toolbox.setter(conf, path, opts);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        require(&#x22;./test/server&#x22;).startServer();
    });

    grunt.registerTask(&#x27;autotest&#x27;, &#x27;watch and test&#x27;, function(argPattern) {

        var watched= [&#x22;lib/**/*.js&#x22;, &#x22;test/**/*.js&#x22;, &#x22;models/**/*.js&#x22;, &#x22;extensions/**/*.js&#x22
;];
       // set the correct list of file to watch according to the argument passed
        grunt.<span class="apidocCodeKeywordSpan">config</span>(&#x27;watch.autotest.files&#x27;, watched);
        grunt.config(&#x27;watch.autotest.tasks&#x27;,  (argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;));
        grunt.task.run(argPattern? &#x27;test:&#x27;+ argPattern: &#x27;test&#x27;);
        grunt.task.run(&#x27;watch:autotest&#x27;);

    })
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.login_service.getContext" id="apidoc.element.angoose.login_service.getContext">
        function <span class="apidocSignatureSpan">angoose.login_service.</span>getContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContext = function (){
    return require(&#x22;./angoose&#x22;).getContext()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.

For each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains
the request
and response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent
 code paths, including in async callback functions.

To obtain the context, you may simple call:

 angoose.<span class="apidocCodeKeywordSpan">getContext</span>()

Some of the common usage with the getContext() method:

angoose.getContext().getRequest():  returns the Express request object
angoose.getContext().getRequest().session Get Express request session.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.login_service.getSchema" id="apidoc.element.angoose.login_service.getSchema">
        function <span class="apidocSignatureSpan">angoose.login_service.</span>getSchema
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSchema(){
    var thisClass = this;
    var schema = {statics: {}, methods:{} };
    for(var name in thisClass){
        var val = thisClass[name];
        if( filter(name) ) continue;
        if(typeof (val) != &#x27;function&#x27;) continue;
        schema.statics[name] = val;
    }
    if(typeof(thisClass) == &#x27;function&#x27;){
        schema.methods = _.extend({}, thisClass.prototype)
    }
    return schema;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(schemaObj.statics[funcName]) ftype+=&#x3c;span class=&#x22;string
&#x22;&#x3e;&#x27;static&#x27;&#x3c;/span&#x3e;;
    ftype+=&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;_&#x22;&#x3c;/span&#x3e; + getFunctionAnnotation(funcBody);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; ftype;
}

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; stringify = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span
 class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(modelName, model)&#x3c;/span&#
x3e;{&#x3c;/span&#x3e;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcs = {};
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; schemaObj =  model.schema || model.<span class="apidocCodeKeywordSpan
">getSchema</span>();
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcStringifier = &#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c
;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(key, value)&#x3c;/span&#
x3e; {&#x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e; (&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#
x3e; value !== &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;function&#x27;&#x3c;/span&#x3e;) &#x3c;span class=&#x22;keyword&#x22
;&#x3e;return&#x3c;/span&#x3e; value;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; body =  value.toString();

    &#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; funcType = getFunctionType(schemaObj, key, body);
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(!funcType) &#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c
;/span&#x3e;; &#x3c;span class=&#x22;comment&#x22;&#x3e;//&#x27;not-available&#x27;;&#x3c;/span&#x3e;
    logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;Stringify function&#x22;&#x3c;/span&#x3e;,key, funcType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.login_service.signin" id="apidoc.element.angoose.login_service.signin">
        function <span class="apidocSignatureSpan">angoose.login_service.</span>signin
        <span class="apidocSignatureSpan">(username, password, $callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signin = function (username, password, $callback){
     var $context = angoose.getContext();
     if (! username || ! password) return $callback(&#x22;Must provide username/password&#x22;);

     UserModel.findOne({&#x22;email&#x22;:  username },  function(err, user) {
                if (err) return $callback(err);
                if(!user){
                    logger().debug(&#x22;user &#x22;, username, &#x22;does not exist&#x22;);
                    return $callback(&#x22;Username/password do not match.&#x22;);
                }
                logger().debug(&#x22;User login: &#x22;, username, password &#x26;&#x26; password.length, user.get(&#x22;password.salt&#x22;))

                //var hashedPassword = require(&#x22;crypto&#x22;).pbkdf2Sync(password);
                var hashedPassword = password;

                if(user.password !== hashedPassword){
                    logger().debug(&#x22;user &#x22;, username, &#x22;password did not match&#x22;);
                    return $callback(&#x22;Username/password do not match.&#x22;);
                }
                // A login module must: 1) Implement a signin method 2) callback with an object with userId and roles properties
                user.userId = user._id;
                user.roles = user.roles;

                // keep user in session, optional
                $context.getRequest().session.user = user;
                $callback(false, user);
        }); // end inContext
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    myService.allowedOp(function(err, ret ){
       console.log(&#x22;allowedOp result&#x22;, err, ret)
       assert.equal(err,&#x27;Access Denied&#x27;);
       done();
    });
});
it(&#x22;forbiddenOp should be allowed by super user admin &#x22;, function(done){
    myService.<span class="apidocCodeKeywordSpan">signin</span>(&#x27;admin&#x27;, &#x27;xxx&#x27;, function(err, user){
        myService.forbiddenOp(function(err, ret ){
           console.log(&#x22;forbiddenOp result&#x22;, err, ret)
           assert.equal( ret ,&#x27;NotOK&#x27;);
           done();
        });
    })
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.login_service.signout" id="apidoc.element.angoose.login_service.signout">
        function <span class="apidocSignatureSpan">angoose.login_service.</span>signout
        <span class="apidocSignatureSpan">( $callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signout = function ( $callback){
    var $context = angoose.getContext();
    $context.getRequest().session.user = null;
    $callback(false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           done();
        });
    })
});

it(&#x22;AloowedOp operation is not allowed after log out &#x22;, function(done){
    myService.signin(&#x27;someuser&#x27;, &#x27;other&#x27;, function(err, user){
        myService.<span class="apidocCodeKeywordSpan">signout</span>(&#x27;someuser&#x27;, function(err, user){
            myService.allowedOp(function(err, ret ){
               console.log(&#x22;after signing out &#x22;, err, ret)
               assert.equal(err,&#x27;Access Denied&#x27;);
               done();
            });
        });
    })
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.toolbox" id="apidoc.module.angoose.toolbox">module angoose.toolbox</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.toolbox.addHookPoints" id="apidoc.element.angoose.toolbox.addHookPoints">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>addHookPoints
        <span class="apidocSignatureSpan">(clazz, hookables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHookPoints = function (clazz, hookables){
    var hooks = require(&#x22;hooks&#x22;);
    hookables = hookables || clazz.hookables;
    for (var k in hooks) { clazz[k] = hooks[k];}

    _.each(hookables, function(hookable){
        clazz.hook(hookable, clazz.prototype[hookable]);
    });
    clazz.removePost = removePost;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    invokeHook(&#x27;post&#x27;, &#x27;createBundle&#x27;, clientData);

    invokeHook(&#x27;post&#x27;, &#x27;generateClient&#x27;, clientData);

};
//@tood: ,serializeModules,serializeModule,prepareSchema
// Bundle.hookables = &#x27;generateClient,configClient,exportModules,exportModule,createBundle&#x27;.split(&#x22;,&#x22;);
// toolbox.<span class="apidocCodeKeywordSpan">addHookPoints</span>(Bundle);

Bundle.typeOf = toolbox.typeOf;
module.exports = Bundle;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.async" id="apidoc.element.angoose.toolbox.async">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>async
        <span class="apidocSignatureSpan">(fn, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function async(fn, scope){
    return function(){
        var args = arguments
        process.nextTick(function(){
            fn.apply(scope, args)
        })
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* calls the generator and also ends the promise chain, so that any
* unhandled errors are thrown instead of forwarded to the error
* handler. This is useful because it&#x27;s extremely common to run
* generators at the top-level to work with libraries.
*/
Q.spawn = spawn;
function spawn(makeGenerator) {
   Q.done(Q.<span class="apidocCodeKeywordSpan">async</span>(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
* Throws a ReturnValue exception to stop an asynchronous generator.
*
* This interface is a stop-gap measure to support generator return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.bindCallback" id="apidoc.element.angoose.toolbox.bindCallback">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>bindCallback
        <span class="apidocSignatureSpan">(scope, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindCallback = function (scope, fn){
    return function(){
        var lastArg = arguments.length? arguments[arguments.length-1]: null;
        if(typeof(lastArg) != &#x27;function&#x27;) return fn.apply(scope || this, arguments);
        var domain =require(&#x22;domain&#x22;);
        if(domain.active){
            arguments[arguments.length-1] = domain.active.bind(lastArg);
        }
        return fn.apply(scope || this, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function bindMongooseMethods(modelClass){
var staticMethods = &#x22;populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update
,remove,count,geoNear,geoSearch,aggregate&#x22;.split(&#x22;,&#x22;);
_.each(staticMethods, function(method){
    var fn = modelClass[method];
    if( typeof(fn) == &#x27;function&#x27;){
        modelClass[method] =  toolbox.<span class="apidocCodeKeywordSpan">bindCallback</span>(modelClass, fn )
    }
});
var instanceMethods = &#x22;save,remove,populate,update&#x22;.split(&#x22;,&#x22;);
_.each(instanceMethods, function(method){
    var fn = modelClass.prototype[method];
    if( typeof(fn) == &#x27;function&#x27;){
        modelClass.prototype[method] =  toolbox.bindCallback(null, fn )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.camelcase" id="apidoc.element.angoose.toolbox.camelcase">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>camelcase
        <span class="apidocSignatureSpan">(name, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cammelcase(name, space){
    // converting client-user to ClientUser
    if(!name) return name;
    var parts = name.split(&#x22;-&#x22;);
    name = &#x22;&#x22;;
    for(var i=0;i&#x3c; parts.length;i++){
        if(parts[i] &#x26;&#x26; parts[i].length&#x3e;0){
            name = name &#x26;&#x26; space ? name+&#x22; &#x22;:name;
            name+= parts[i].substring(0,1).toUpperCase() + parts[i].substring(1);
        }
    }
    return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(user &#x26;&#x26; user.getRoles().indexOf(superrole) &#x3e;=0) return next();

logger().trace(&#x22;in auth.postAuth:&#x22;, invocation.clazz, invocation.method);
if(invocation.method == &#x27;signin&#x27; || invocation.method==&#x22;signout&#x22;) return next();

var mod = angoose.module( invocation.clazz );
var category = mod.config(EXTENSION +&#x22;.category&#x22;) || invocation.clazz;
var group = toolbox.<span class="apidocCodeKeywordSpan">camelcase</span>(getGroup(mod, invocation.method)) || invocation.method;

 var roles = user.getRoles() ? user.getRoles(): [];
 roles = Array.isArray(roles)? roles: [ roles ];
 if(roles.indexOf(&#x27;guest&#x27;) &#x3c;0) roles.push(&#x27;guest&#x27;);
 if(roles.indexOf(&#x27;authenticated&#x27;) &#x3c;0) roles.push(&#x27;authenticated&#x27;);

var allowed = isAllowed( category +&#x22;.&#x22;+ group, roles, function(allowed){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.decamelcase" id="apidoc.element.angoose.toolbox.decamelcase">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>decamelcase
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decamelcase(name){
    // convert ClientUser to client-user
    if(!name) return name;
    var ret = &#x22;&#x22;;
    for(var i=0;i&#x3c;name.length;i++){
        var c = name.charAt(i);
        if(c.toLowerCase() != c &#x26;&#x26; ret.length&#x3e;0) ret+=&#x22;-&#x22;
        ret += c;
    }
    return ret.toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.exportModuleMethods" id="apidoc.element.angoose.toolbox.exportModuleMethods">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>exportModuleMethods
        <span class="apidocSignatureSpan">(moduleName, mod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportModuleMethods = function (moduleName, mod){
    var ret = {};
    var schemaObj =  mod.schema || (mod.getSchema &#x26;&#x26; mod.getSchema());
    if(!schemaObj)
        return null;
    ret.moduleName = moduleName;
    ret.methods = _.clone( schemaObj.methods ) || {};
    ret.statics = _.clone( schemaObj.statics) || {};
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};
           authSchema.add(field);
       }
    };
});
var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)&#x3e;=0? angoose.getMongoose().model(MODEL_NAME):angoose
.getMongoose().model(MODEL_NAME, authSchema) ;
var permModule = angoose.module(MODEL_NAME, mongooseModel);
new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.<span class="apidocCodeKeywordSpan">exportModuleMethods</span>(
MODEL_NAME, permModule);
logger().debug(&#x22;Added mongoose model&#x22;, MODEL_NAME);

setupInitialRoles();
};

function postInvoke(next, invocation){
// this is bizzare, if main method fails, this will be called with arguments meant for pre()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.getter" id="apidoc.element.angoose.toolbox.getter">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>getter
        <span class="apidocSignatureSpan">(doc, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getter = function (doc, path){
    if(!path || !doc) return undefined;
     var   pieces = path.split(&#x27;.&#x27;);
      var obj = doc;
      for (var i = 0, l = pieces.length; i &#x3c; l; i++) {
        obj = undefined === obj || null === obj
          ? undefined
          : obj[pieces[i]];
      }
      return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
module.exports = angoose.extension(&#x27;MongooseExtension&#x27;, plugin);

function formatError(next, invocation){
var ex = invocation.packed.exception;
console.log(&#x22;Intercepting error&#x22;, ex);
// check if it&#x27;s mongoose&#x27;s model error
var errors = toolbox.<span class="apidocCodeKeywordSpan">getter</span>(ex , &#x27;cause.errors&#x27;);
if( errors){
    // format model error
    var msg = &#x27;&#x27;;
    Object.keys(errors).forEach(function(key){
        var errobj = errors[key];
        var m = errobj.message+&#x22;&#x22;;
        msg = msg+m+&#x22; &#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.merge" id="apidoc.element.angoose.toolbox.merge">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>merge
        <span class="apidocSignatureSpan">(dst, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (dst, src){
    dst = dst || {};
    src = src || {};
    var traverse = require(&#x22;traverse&#x22;);
    var source = traverse(src);
    var destination = traverse(dst);
    source.paths().forEach(function(path){
        var val = source.get(path);
        if(typeof(val) != &#x27;object&#x27;)
            destination.set(path, val);
    });
    return dst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         if(val === undefined)
            return toolbox.getter(options, path);
         toolbox.setter(options, path, val);
    }

    if(typeof(path) === &#x27;object&#x27;){
        // deep merge
        options = toolbox.<span class="apidocCodeKeywordSpan">merge</span>(options, path);

    }
}

function moduleNames(){
    return Object.keys(beans);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.methodType" id="apidoc.element.angoose.toolbox.methodType">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>methodType
        <span class="apidocSignatureSpan">(funcBody)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodType = function (funcBody){
    funcBody = typeof(funcBody) == &#x27;function&#x27; ? funcBody.toString() : funcBody;
    if(funcBody.indexOf(&#x22;function&#x22;)!=0) return &#x22;unknown&#x22;;
    var matcher = FunctionNamePattern.exec(funcBody);
    return matcher? matcher[1]: &#x27;remote&#x27;; //default is remote
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(mod.config &#x26;&#x26; mod.config(&#x22;visibility&#x22;) === false ) return;
var category = getCategory(mod);
for(var i=0;methodNames &#x26;&#x26; i&#x3c;methodNames.length;i++){
   var mName = methodNames[i];
   if(mName == &#x27;config&#x27; || mName == &#x27;getSchema&#x27;) continue;
   var fn = schema.methods &#x26;&#x26; schema.methods[mName];
   fn = fn || (schema.statics &#x26;&#x26; schema.statics[mName]);
   if(toolbox.<span class="apidocCodeKeywordSpan">methodType</span>(fn) != &#x27;remote&#x27;) continue;

   var group = getGroup(mod, mName);
   if(!group){
       var path = category +&#x22;.&#x22; + mName;
       var field = {};
       field[path] = {type:Boolean, label: getLabel(mod,mName)};
       authSchema.add(field);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.parseDeclaredArguments" id="apidoc.element.angoose.toolbox.parseDeclaredArguments">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>parseDeclaredArguments
        <span class="apidocSignatureSpan">(funcBody)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDeclaredArguments = function (funcBody){
    if(typeof funcBody === &#x27;function&#x27;) funcBody = funcBody.toString();
    if(funcBody &#x26;&#x26; typeof funcBody === &#x22;string&#x22;  &#x26;&#x26; funcBody.substr(0,8) == &#x22;function&#x22;) {
        var startArgs = funcBody.indexOf(&#x27;(&#x27;) + 1;
        var endArgs = funcBody.indexOf(&#x27;)&#x27;);
        return  funcBody.substring(startArgs, endArgs)
    }
    return &#x22;&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#
x22;title&#x22;&#x3e;formatError&#x3c;/span&#x3e; &#x3c;span class=&#x22;params&#x22;&#x3e;(ex, seqnumber)&#x3c;/span&#x3e;{&#x3c
;/span&#x3e;
logger.debug(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;====== END RMI with Error  #&#x22;&#x3c;/span&#x3e;, seqnumber,  ex);
&#x3c;span class=&#x22;keyword&#x22;&#x3e;return&#x3c;/span&#x3e; {success:&#x3c;span class=&#x22;literal&#x22;&#x3e;false&#x3c;/
span&#x3e;, exception:ex, seqnumber: seqnumber };
}

&#x3c;span class=&#x22;function&#x22;&#x3e;&#x3c;span class=&#x22;keyword&#x22;&#x3e;function&#x3c;/span&#x3e; &#x3c;span class=&#
x22;title&#x22;&#x3e;injectDependencies&#x3c;/span&#x3e;&#x3c;span class=&#x22;params&#x22;&#x3e;(func, args, ctx, callback )&#x3c
;/span&#x3e;{&#x3c;/span&#x3e;

&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; declaredArguments = schemaUtil.<span class="apidocCodeKeywordSpan
">parseDeclaredArguments</span>(func);
declaredArguments = declaredArguments.replace(&#x3c;span class=&#x22;regexp&#x22;&#x3e;/\s+/g&#x3c;/span&#x3e;, &#x3c;span class
=&#x22;string&#x22;&#x3e;&#x22;&#x22;&#x3c;/span&#x3e;).split(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;,&#x22;&#x3c;/span&#
x3e;);
logger.trace(&#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;injectDependencies() declaredArguments: &#x22;&#x3c;/span&#x3e;, declaredArguments
, &#x3c;span class=&#x22;string&#x22;&#x3e;&#x22;provided args:&#x22;&#x3c;/span&#x3e;, args);
&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; useCallback = &#x3c;span class=&#x22;literal&#x22;&#x3e;false&#x3c
;/span&#x3e;;
&#x3c;span class=&#x22;keyword&#x22;&#x3e;for&#x3c;/span&#x3e;(&#x3c;span class=&#x22;keyword&#x22;&#x3e;var&#x3c;/span&#x3e; i=&#
x3c;span class=&#x22;number&#x22;&#x3e;0&#x3c;/span&#x3e;;i&#x26;lt;declaredArguments.length;i++){
    &#x3c;span class=&#x22;comment&#x22;&#x3e;/** if client did not provide enough number of arguments, we fill it with null*/&#
x3c;/span&#x3e;
    &#x3c;span class=&#x22;keyword&#x22;&#x3e;if&#x3c;/span&#x3e;(&#x3c;span class=&#x22;keyword&#x22;&#x3e;typeof&#x3c;/span&#x3e
;( args[i]) == &#x3c;span class=&#x22;string&#x22;&#x3e;&#x27;undefined&#x27;&#x3c;/span&#x3e;)
        args[i] = &#x3c;span class=&#x22;literal&#x22;&#x3e;undefined&#x3c;/span&#x3e;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.patchMongoCallback" id="apidoc.element.angoose.toolbox.patchMongoCallback">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>patchMongoCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchMongoCallback = function (){
	var mongodbs = [];
	
	try{
        mongodbs.push( require(process.cwd() + &#x22;/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db&#x22;).Db );
    }
    catch(err){
    }
	try{
		mongodbs.push( require(&#x22;mongoose/node_modules/mongodb/lib/mongodb/db&#x22;).Db );
	}
	catch(err){
	}
	try{
        mongodbs.push( require(&#x22;mongodb/lib/mongodb/db&#x22;).Db );
    }
    catch(err){
    }
    try{
        mongodbs.push( require(&#x22;../mongodb/lib/mongodb/db&#x22;).Db );
    }
    catch(err){
    }

	for(var i=0;i&#x3c;mongodbs.length;i++){
		var mongodb = mongodbs[i];
		mongodb.prototype._executeInsertCommand = bindMongoCallback(mongodb.prototype._executeInsertCommand);
		mongodb.prototype._executeQueryCommand = bindMongoCallback(mongodb.prototype._executeQueryCommand);
		mongodb.prototype._executeUpdateCommand = mongodb.prototype._executeInsertCommand ;
		mongodb.prototype._executeRemoveCommand = mongodb.prototype._executeInsertCommand ;
	}
	var domain = require(&#x22;domain&#x22;);
	function bindMongoCallback(fn){
		return function(cmd, options, callback){
			if(domain.active){
				if(typeof(callback) ===&#x27;function&#x27;) callback = domain.active.bind(callback);
				else if(!callback &#x26;&#x26; typeof(options) === &#x27;function&#x27;) options = domain.active.bind(options);
			}
			else{
			    //console.error(&#x22;DOMAIN LOST&#x22;, cmd.collectionName, cmd.query);
			}
			fn.call(this, cmd, options,callback  );
		};
	};

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var angoose = require(&#x22;../lib/angoose&#x22;);
var toolbox = require(&#x22;../lib/util/toolbox&#x22;);
var EXTENSION = &#x27;angoose-mongoose&#x27;;
var path= require(&#x22;path&#x22;),traverse = require(&#x22;traverse&#x22;),hooks= require(&#x22;hooks&#x22;), Q = require(&#x22
;q&#x22;);
var fs = require(&#x22;fs&#x22;),  _ =require(&#x22;underscore&#x22;);

toolbox.<span class="apidocCodeKeywordSpan">patchMongoCallback</span>();

var plugin = {
postResolveTarget: postResolveTarget,
postInvoke: postInvoke,
postPack: postPack,
postExportModule: decorateMongooseSchema,
afterFormatError: formatError
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.patchQ" id="apidoc.element.angoose.toolbox.patchQ">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>patchQ
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchQ = function (){

<span class="apidocCodeCommentSpan">    /** Workaround for Q module with CLS */
</span>    function matroshka(fn) {
      var babushka = fn;
      Object.keys(process.namespaces).forEach(function (name) {
        babushka = process.namespaces[name].bind(babushka);
      });

      return babushka;
    }
    function patchQueue() {
      var Q = require(&#x27;q&#x27;);
      var proto = Q &#x26;&#x26; Q.makePromise &#x26;&#x26; Q.makePromise.prototype;
      function wrapperFunc(then) {
        return function nsThen(fulfilled, rejected, progressed) {
          if (typeof fulfilled === &#x27;function&#x27;) fulfilled = matroshka(fulfilled);
          if (typeof rejected === &#x27;function&#x27;) rejected = matroshka(rejected);
          if (typeof progressed === &#x27;function&#x27;) progressed = matroshka(progressed);
          return then.call(this, fulfilled, rejected, progressed);
        };
      }
      require(&#x22;shimmer&#x22;).wrap(proto, &#x27;then&#x27;, wrapperFunc);
      require(&#x22;shimmer&#x22;).wrap(proto, &#x27;done&#x27;, wrapperFunc);
    }

    patchQueue();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.removeHookPoints" id="apidoc.element.angoose.toolbox.removeHookPoints">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>removeHookPoints
        <span class="apidocSignatureSpan">(clazz, hookables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeHookPoints = function (clazz, hookables){
    hookables = hookables || clazz.hookables;
    _.each(hookables, function(hookable){
        clazz.removePre(hookable).removePost(hookable);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return angoose.mongoose;
}
function noop(){};


function hookupExtensions(){
logger.debug(&#x22;Searching Extensions in Modules&#x22;);
toolbox.<span class="apidocCodeKeywordSpan">removeHookPoints</span>(Pipeline);
Bundle.initHooks();
Object.keys(beans).forEach(function(bname){
    var bean = beans[bname];
    if(!bean._angoosemeta.isExtension) return;
    logger.debug(&#x22;Loading extension&#x22;, bname);
    bean.config(&#x27;visibility&#x27;, false);
    registerHook(bean, bname);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.setter" id="apidoc.element.angoose.toolbox.setter">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>setter
        <span class="apidocSignatureSpan">(doc, path, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setter = function (doc, path, val){
    if(!path || !doc ) return;
     var   pieces = path.split(&#x27;.&#x27;);
      var obj = doc;
      for (var i = 0, len = pieces.length; i &#x3c; len; i++) {
          if(i+1  == len ) // last one
          {
              obj[ pieces[i]] = val;
              return;
          }
          obj[pieces[i]] = obj[pieces[i]] || {};
          obj = obj[pieces[i]] || {};
      }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function initialConfig(conf){
 options = _.extend({}, DEFAULT_OPTIONS);

 /** overrite default configurations */
Object.keys(conf).forEach(function(key){
    toolbox.<span class="apidocCodeKeywordSpan">setter</span>(options, key,  conf[key]); // this way we will allow &#x22;forms.url
.prefix&#x22; type of configuration
})
 //_.extend(options, conf );
 if(conf &#x26;&#x26; conf.urlPrefix)  options[&#x27;url-prefix&#x27;] = conf.urlPrefix;
 if(conf &#x26;&#x26; conf.modelDir)  options[&#x27;module-dirs&#x27;] = conf.modelDir;
 if(conf &#x26;&#x26; conf.mongo_opts)  options[&#x27;mongo-opts&#x27;] = conf.mongo_opts;
 if(conf &#x26;&#x26; conf.clientFile)  options[&#x27;client-file&#x27;] = conf.clientFile;
 logger.setLevel( options.logging || &#x27;INFO&#x27; );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.stringifySchema" id="apidoc.element.angoose.toolbox.stringifySchema">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>stringifySchema
        <span class="apidocSignatureSpan">(schemaObj )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringifySchema = function (schemaObj ){
    //logger.trace(&#x22;stringifySchema&#x22;, moduleName);
    var funcs = {};
    function funcStringifier(key, value) {
        if (typeof value !== &#x27;function&#x27;) return value;
        var body =  value.toString();
        var funcType = exports.typeOf(body);
        if(!funcType) return; //&#x27;not-available&#x27;;
        if(funcType.indexOf(&#x22;local&#x22;)&#x3e;=0) return &#x27;This method can be invoked from server side only&#x27;;

        if(funcType.indexOf(&#x22;portable&#x22;)&#x3e;=0){
<span class="apidocCodeCommentSpan">            /** the function can be executed client side */
</span>           return body;
        }
        else{
            /** stub the function */
            return &#x27;$PROXIED$&#x27;; //constructProxyFunc(key,args, funcType);
        }
    }
    return JSON.stringify( schemaObj,  funcStringifier, &#x22;\t&#x22;  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
invokeHook(&#x27;post&#x27;, &#x27;exportModules&#x27;, client);
};

proto.createBundle = function(client){
logger.debug(&#x22;Bundle client files&#x22;);

if(client.source) return; // already generated source
var jsonSchemas = toolbox.<span class="apidocCodeKeywordSpan">stringifySchema</span>( client.schemas );
var template = path.resolve(__dirname , &#x22;client/angoose-client.js&#x22;);
var content = fs.readFileSync(template , &#x27;ascii&#x27;);
content = content.replace(&#x22;/**SCHEMA_PLACEHOLDER*/&#x22;,  jsonSchemas);
content = content.replace(&#x22;/**CONFIG_PLACEHOLDER*/&#x22;, JSON.stringify( client.options ));

/**  include client specific extensions*/
var clientModuleFile = path.resolve(__dirname , &#x22;client/angoose-angular.js&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.toolbox.typeOf" id="apidoc.element.angoose.toolbox.typeOf">
        function <span class="apidocSignatureSpan">angoose.toolbox.</span>typeOf
        <span class="apidocSignatureSpan">(funcBody)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeOf = function (funcBody){
    funcBody = typeof(funcBody) == &#x27;function&#x27; ? funcBody.toString() : funcBody;
    if(funcBody.indexOf(&#x22;function&#x22;)!=0) return &#x22;unknown&#x22;;
    var matcher = FunctionNamePattern.exec(funcBody);
    return matcher? matcher[1]: &#x27;remote&#x27;; //default is remote
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.stringifySchema = function(schemaObj ){
//logger.trace(&#x22;stringifySchema&#x22;, moduleName);
var funcs = {};
function funcStringifier(key, value) {
    if (typeof value !== &#x27;function&#x27;) return value;
    var body =  value.toString();
    var funcType = exports.<span class="apidocCodeKeywordSpan">typeOf</span>(body);
    if(!funcType) return; //&#x27;not-available&#x27;;
    if(funcType.indexOf(&#x22;local&#x22;)&#x3e;=0) return &#x27;This method can be invoked from server side only&#x27;;

    if(funcType.indexOf(&#x22;portable&#x22;)&#x3e;=0){
        /** the function can be executed client side */
       return body;
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.angoose.user_model" id="apidoc.module.angoose.user_model">module angoose.user_model</a></h1>


    <h2>
        <a href="#apidoc.element.angoose.user_model.user_model" id="apidoc.element.angoose.user_model.user_model">
        function <span class="apidocSignatureSpan">angoose.</span>user_model
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(doc, fields, skipId) {
  if (!(this instanceof model))
    return new model(doc, fields, skipId);
  Model.call(this, doc, fields, skipId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.angoose.user_model.model" id="apidoc.element.angoose.user_model.model">
        function <span class="apidocSignatureSpan">angoose.user_model.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            promise: myQ
        });
        return AngooseClient;
})
function factoryFunc(modelName){
    console.log(&#x22;Create factory for model &#x22;+ modelName)
    angularModule.factory(modelName , function($http, $q, $rootScope, $timeout, angoose){
        var acModel = AngooseClient.<span class="apidocCodeKeywordSpan">model</span>(modelName);
        resourceAdapt(acModel, $rootScope, $timeout);
        return acModel;
    });
}
angular.forEach( AngooseClient.modelNames(), factoryFunc );

function addDoneMethod($q){
...</pre></li>
    </ul>












</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
